----------------------------------------------- -*- text -*-
-- Langage BLOC : Bloc, Instruction et Expression façon C/Java/...
-- Sémantique : Construction de l'arbre abstrait et gestion de la
--                      table des symboles. 
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=1;


inh gauche	: Expression for SuiteCondition, SuiteTerme, SuiteFacteur;
inh factory	: BlockFactory for Bloc, Instruction,
    		  	       SuiteConditionnelle, Instructions, Expression, Condition,
			       SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur,
			       Type, Valeur, Champ, Affectable, SuiteAffectable, Acces, SuiteNouveau,
			       NomEtendu, SuiteNomEtendu;  

inh tds : SymbolTable for Bloc, Instructions, Instruction, Expression, SuiteConditionnelle,
					Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Type,
					Champs, Champ, Affectable, SuiteAffectable, Expressions, SuiteExpressions, Acces, SuiteNouveau;

inh blocParent	: Block for Instructions;

inh support : Assignable for SuiteAffectable;
syn ast 	: Assignable for SuiteAffectable, Affectable;

inh support : Expression for Acces;
syn ast		: Expression for Acces;

syn expressions : LinkedList<Expression> for Expressions, SuiteExpressions;

inh type : Type for SuiteNouveau, NomEtendu, SuiteNomEtendu;

syn nom : String for NomEtendu;

syn ast		: Block for Programme, Bloc ; 
syn ast		: Expression for Expression, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau;
syn ast		: Type for Type, NomEtendu, SuiteNomEtendu;
syn champ	: FieldDeclaration for Champ ;
syn champs	: LinkedList<FieldDeclaration> for Champs;
syn instr	: Instruction for Instruction ;

syn bin_op	: BinaryOperator for Additif, Multiplicatif, Comparatif;

syn suite_cond_bloc : Block for SuiteConditionnelle;

space  separateur				is    "[\n\r\t ]+";
space  commentaire			is    "\/\/.*\n";
sugar  accolade_ouvrante		is    "\{";  
sugar  accolade_fermante		is    "\}";  
sugar  crochet_ouvrant			is    "\[";  
sugar  crochet_fermant			is    "\]";  
sugar  parenthese_ouvrante		is    "\(";
sugar  parenthese_fermante		is    "\)";
sugar  different				is    "\!=";
sugar  inferieur				is    "\<";  
sugar  superieur				is    "\>";  
sugar  inferieur_egal			is    "\<=";  
sugar  superieur_egal			is    "\>=";  
sugar  point					is    "\.";  
sugar  point_virgule			is    ";";  
sugar  virgule					is    ",";
sugar  affectation				is    "=";
sugar  egalite					is    "==";
sugar  adresse					is    "&";
sugar  nouveau					is    "new";
sugar  addition				is    "\+";
sugar  soustraction				is    "\-";
sugar  ou						is    "\|\|";  
sugar  multiplication			is    "\*";
sugar  division				is    "/";
sugar  modulo					is    "%";
sugar  negation				is    "\!";
sugar  et						is    "&&";
sugar  constante			is	  "const";
sugar  vrai					is    "true";
sugar  faux					is    "false";
sugar  si						is    "if";
sugar  sinon					is    "else";
sugar  afficher					is    "print";
sugar  tant_que				is    "while";
sugar  premier					is    "fst";
sugar  second					is    "snd";
sugar  type_int				is    "int";
sugar  type_bool				is    "boolean";
sugar  enregistrement			is    "struct";
sugar  typedef					is    "typedef";
term   entier					is    "[0-9]+";
term   identificateur			is    "[a-z][a-zA-Z0-9_]*"; 
term   identificateur_type		is    "[A-Z][a-zA-Z0-9_]*"; 


-- Remplacera la règle suivante pour pouvoir traiter les instructions
Programme -> identificateur #inh Bloc #ast ;
#inh {
do
	Bloc^factory := new BlockFactoryImpl();
	Bloc^tds := new SymbolTable();
end
}
#ast {
do
	Programme^ast := Bloc^ast;
end
}

Bloc -> accolade_ouvrante #ast Instructions accolade_fermante ;
#ast {
local
	b : Block;
do
	b := Bloc^factory.createBlock();
	Bloc^ast := b;
	
	Instructions^blocParent := b;
	Instructions^tds := new SymbolTable(Bloc^tds);
end
}


Type -> type_bool #ast ;
#ast {
do
   Type^ast := Type^factory.createBooleanType();  
end
}

Type -> type_int  #ast ;
#ast {
do
   Type^ast := Type^factory.createIntegerType(); 
end
}

Type -> inferieur Type virgule Type superieur  #ast;
#ast {
do
    Type^ast := Type^factory.createCoupleType(Type1^ast, Type2^ast);
end
}

Instructions -> ;

Instructions -> #inh Instruction #ast Instructions ;
#inh {
do
	Instruction^factory := new BlockFactoryImpl();
	
	Instructions1^tds := Instructions^tds;
	Instruction^tds := Instructions^tds;
end
}

#ast {
do
	Instructions^blocParent.add(Instruction^instr);
end
}


Instruction -> typedef #tds Type identificateur_type point_virgule #instr ;
#tds {
do
	Type^tds := Instruction^tds;
end
}

#instr {
local 
   v : TypeDeclaration;
do 
   if Instruction^tds.contains(identificateur_type^txt) then 
      error(BLOC_already_defined, identificateur_type^txt); 
   else
      v := Instruction^factory.createTypeDeclaration(identificateur_type^txt, Type^ast); 
      Instruction^tds.register(v);
      Instruction^instr := v; 
   end 
end 
}

Type -> identificateur_type #ast ;
#ast {
local
   d : Optional<Declaration>;
   t : Declaration;
do
   -- Si l'identificateur de type est connu
   if Type^tds.knows(identificateur_type^txt) then
      -- Lecture dans la table des symboles
      d := Type^tds.get(identificateur_type^txt);
      -- Accès à cet élément
      t := d.get();
      match t
	 -- Si c'est un type, il est renvoyé
         with TypeDeclaration then Type^ast := t.getType();
         -- Sinon une erreur est signalée
      else
            error(BLOC_not_a_type,identificateur_type^txt);
      end
   -- Sinon une erreur est signalée
   else
      error(BLOC_undefined_ident,identificateur_type^txt);
   end
end
}

-- Type enregistrement composé de champs
Type -> enregistrement identificateur_type accolade_ouvrante #inh #tds Champs accolade_fermante #ast ;
global
t : RecordType;
#inh {
do
   if (Type^tds.contains( identificateur_type^txt)) then
      error(BLOC_already_defined,identificateur_type^txt);
   else
      t := Type^factory.createRecordType( identificateur_type^txt );
      Type^tds.register( t );
   end
end
}

#tds {
do
	Champs^tds := Type^tds;
end
}

#ast {
do
   -- Création d'un noeud type Enregistrement initialisé avec les champs
   t.addAll(Champs^champs);
   Type^ast := t; 
end 
}

Champs -> #inh Champ Champs #champs;

#inh {
do
	Champ^factory := new BlockFactoryImpl();
	
	Champ^tds := Champs^tds;
	Champs1^tds := Champs^tds;
end
}

#champs { 
local  
   champs : LinkedList<FieldDeclaration>;  
do  
   champs :=  Champs1^champs;  
   champs.addFirst(Champ^champ);  
   Champs^champs := champs;  
end  
}
 
Champs -> #champs;  
#champs { 
do  
   Champs^champs := new LinkedList<FieldDeclaration>();  
end  
}
 
Champ -> #tds Type identificateur point_virgule #ast;
#tds {
do
	Type^tds := Champ^tds;
end
}

#ast { 
do  
   Champ^champ := Champ^factory.createFieldDeclaration( identificateur^txt, Type^ast);  
end  
}


Instruction -> constante Type identificateur affectation Valeur point_virgule #instr;

#instr {
local
	d : ConstantDeclaration;
do
	if Instruction^tds.contains(identificateur^txt) then
		error(Error);
	else
		d := Instruction^factory.createConstantDeclaration(identificateur^txt, Type^ast, Valeur^ast);
		
		Instruction^tds.register(d);
		Instruction^instr := d;
	end
end
}

Instruction -> #tds Affectable affectation Expression point_virgule #instr;

#tds {
do
	Expression^tds := Instruction^tds;
	Affectable^tds := Instruction^tds;
end
}

#instr {
do
	Instruction^instr := Instruction^factory.createAssignment( Affectable^ast, Expression^ast);
end
}

Affectable -> identificateur #tds #inh SuiteAffectable #ast ;

#tds {
do
   SuiteAffectable^tds := Affectable^tds;
end
}

#inh {
local
   o : Optional<Declaration>;
   d : Declaration;
do
   if (Affectable^tds.knows(identificateur^txt)) then
      o := Affectable^tds.get(identificateur^txt);
      d := o.get();
      match d
      with VariableDeclaration then SuiteAffectable^support := Affectable^factory.createVariableAssignment( d );
      with ConstantDeclaration then error(BLOC_not_a_variable, identificateur^txt);
      end
   else
      error(BLOC_undefined_ident, identificateur^txt);
   end
end
}

#ast {
do
   Affectable^ast := SuiteAffectable^ast;
end
}

SuiteAffectable -> #ast ;

#ast { 
do  
   SuiteAffectable^ast := SuiteAffectable^support;  
end  
}
 
SuiteAffectable -> point identificateur #inh SuiteAffectable #ast;

#inh {
do
   SuiteAffectable1^tds := SuiteAffectable^tds;
   SuiteAffectable1^support := SuiteAffectable^factory.createFieldAssignment(SuiteAffectable^support,identificateur^txt);
end
}

#ast { 
do  
   SuiteAffectable^ast := SuiteAffectable1^ast;  
end  
}

Instruction -> si parenthese_ouvrante #tds Expression parenthese_fermante Bloc SuiteConditionnelle #instr;

#tds {
do
	Expression^tds := Instruction^tds;
	SuiteConditionnelle^tds := Instruction^tds;
	
	Bloc^tds := new SymbolTable(Instruction^tds);
end
}

#instr {
local
	sc_bloc : Block;
do
	sc_bloc := SuiteConditionnelle^suite_cond_bloc;
	
	if sc_bloc = null then
		Instruction^instr := Instruction^factory.createConditional(Expression^ast, Bloc^ast);
	else
		Instruction^instr := Instruction^factory.createConditional(Expression^ast, Bloc^ast, sc_bloc);
	end
end
}

SuiteConditionnelle -> #suite_cond_bloc;
#suite_cond_bloc {
do
	SuiteConditionnelle^suite_cond_bloc := null;
end
}

SuiteConditionnelle ->sinon #tds Bloc #suite_cond_bloc;
#tds {
do
	Bloc^tds := new SymbolTable(SuiteConditionnelle^tds);
end
}
#suite_cond_bloc {
do
	SuiteConditionnelle^suite_cond_bloc := Bloc^ast;
end
}

Instruction -> tant_que parenthese_ouvrante #tds Expression parenthese_fermante Bloc #instr;

#tds {
do
	Expression^tds := Instruction^tds;
	Bloc^tds := new SymbolTable(Instruction^tds);
end
}

#instr {
do
	Instruction^instr := Instruction^factory.createRepetition(Expression^ast, Bloc^ast);
end
}

Instruction -> afficher parenthese_ouvrante Expression parenthese_fermante point_virgule #instr;
#instr {
do
	Instruction^instr := Instruction^factory.createPrinter(Expression^ast);
end
}

Expression -> #tds Condition #inh SuiteCondition #ast ;
#tds {
do
	Condition^tds := Expression^tds;
	SuiteCondition^tds := Expression^tds;
end
}

#inh {
do
   SuiteCondition^gauche := Condition^ast ;
end 
}
#ast {
do
    Expression^ast := SuiteCondition^ast;
end 
}

SuiteCondition -> #tds Comparatif Condition #ast ;
#tds {
do
	Condition^tds := SuiteCondition^tds;
end
}

#ast {
do
	SuiteCondition^ast :=
	SuiteCondition^factory.createBinaryExpression(
	SuiteCondition^gauche,
	Comparatif^bin_op,
	Condition^ast);
end 
}

SuiteCondition -> #ast ;
#ast {
do
   SuiteCondition^ast := SuiteCondition^gauche;
end 
}

Comparatif -> egalite #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Equals;
end
}

Comparatif -> different #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.Different;   
end  
}
  
Comparatif -> inferieur #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.Lesser;   
end  
}
  
Comparatif -> inferieur_egal #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.LesserOrEqual;   
end  
}
  
Comparatif -> superieur #texte;  
#texte {   
do  
   Comparatif^bin_op := BinaryOperator.Greater;    
end  
}
   
Comparatif -> superieur_egal #texte;  
#texte {   
do  
   Comparatif^bin_op := BinaryOperator.GreaterOrEqual;    
end  
}

Condition -> #tds Terme #ast_inh SuiteTerme #ast_syn ;
#tds {
do
	Terme^tds := Condition^tds;
	SuiteTerme^tds := Condition^tds;
end
}

#ast_inh {
do 
   SuiteTerme^gauche := Terme^ast; 
end 
}

#ast_syn {
do
   Condition^ast := SuiteTerme^ast; 
end
}

SuiteTerme -> Additif #tds Terme #ast_inh SuiteTerme #ast_syn ;
#tds {
do
	SuiteTerme1^tds := SuiteTerme^tds;
	Terme^tds := SuiteTerme^tds;
end
}

#ast_inh {
do
   SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
      SuiteTerme^gauche,  
      Additif^bin_op,  
      Terme^ast);  
end 
}

#ast_syn {
do 
   SuiteTerme^ast := SuiteTerme1^ast; 
end 
}

SuiteTerme -> #ast ;
#ast {
do
   SuiteTerme^ast := SuiteTerme^gauche;
end
}

Additif -> addition #ast;  
#ast { 
do  
   Additif^bin_op := BinaryOperator.Add;  
end  
}

Additif -> soustraction #ast;  
#ast {  
do  
   Additif^bin_op := BinaryOperator.Substract;   
end  
}
   
Additif -> ou #ast;  
#ast {  
do  
   Additif^bin_op := BinaryOperator.Or;   
end  
}
  
Terme -> #tds Facteur #ast_inh SuiteFacteur #ast_syn ;
#tds {
do
	Facteur^tds := Terme^tds;
	SuiteFacteur^tds := Terme^tds;
end
}
#ast_inh {
do 
   SuiteFacteur^gauche := Facteur^ast; 
end 
}

#ast_syn {
do
   Terme^ast := SuiteFacteur^ast; 
end
}

SuiteFacteur -> Multiplicatif #tds Facteur #ast_inh SuiteFacteur #ast_syn ;
#tds {
do
	Facteur^tds := SuiteFacteur^tds;
	SuiteFacteur1^tds := SuiteFacteur^tds;
end
}

#ast_inh {
do 
   SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
      SuiteFacteur^gauche,  
      Multiplicatif^bin_op,  
      Facteur^ast);  
end 
}

#ast_syn {
do 
   SuiteFacteur^ast := SuiteFacteur1^ast; 
end 
}
 
SuiteFacteur -> #ast;  
#ast {
do
   SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

Multiplicatif -> multiplication #ast; 
#ast {
do 
   Multiplicatif^bin_op := BinaryOperator.Multiply; 
end 
}

Multiplicatif -> division #ast; 
#ast { 
do 
   Multiplicatif^bin_op := BinaryOperator.Divide;  
end 
}
 
Multiplicatif -> modulo #ast; 
#ast {  
do 
   Multiplicatif^bin_op := BinaryOperator.Modulo;   
end 
}
  
Multiplicatif -> et #ast; 
#ast {  
do 
   Multiplicatif^bin_op := BinaryOperator.And;   
end 
}

Facteur -> parenthese_ouvrante #tds Expression parenthese_fermante #ast;  
#tds {
do
	Expression^tds := Facteur^tds;
end
}
#ast { 
do  
   Facteur^ast := Expression^ast;  
end  
}
 
Facteur -> Valeur #ast;
#ast {
do
   Facteur^ast := Valeur^ast;
end
}
 
Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt); 
end
}

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);  
end
}

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);  
end
}

Facteur -> identificateur #tds #inh Acces #ast ;
#tds {
do
   Acces^tds := Facteur^tds;
end
}

#inh {
local
   f : Optional<Declaration>;
   d : Declaration;
do
   if (Facteur^tds.knows(identificateur^txt)) then
      f := Facteur^tds.get(identificateur^txt);
      d := f.get();
      match d
      with ConstantDeclaration then Acces^support := d.getValue();
      with VariableDeclaration then Acces^support := Facteur^factory.createVariableUse(d);
      end
   else
      error(BLOC_undefined_ident, identificateur^txt);
   end
end
}

#ast {
do
   Facteur^ast := Acces^ast;
end
}

Acces -> #ast ;

#ast { 
do  
   Acces^ast := Acces^support;  
end  
}
 
Acces -> point identificateur #inh Acces #ast;

#inh {
do
   Acces1^tds := Acces^tds;
   Acces1^support := Acces^factory.createFieldAccess(Acces^support,identificateur^txt);
end
}

#ast { 
do  
   Acces^ast := Acces1^ast;  
end  
}


Facteur -> soustraction #tds Facteur #ast ;  
#tds {
do
   Facteur1^tds := Facteur^tds;
end
}

#ast { 
do  
   Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);  
end  
}
 
Facteur -> negation #tds Facteur #ast ;  
#tds {
do
   Facteur1^tds := Facteur^tds;
end
}

#ast {
do
   Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);  
end  
}
 
Facteur -> premier #tds Facteur #ast;
#tds {
do
   Facteur1^tds := Facteur^tds;
end
}

#ast {
do
   Facteur^ast := Facteur^factory.createFirst(Facteur1^ast);
end
} 

 
Facteur -> second #tds Facteur #ast;
#tds {
do
   Facteur1^tds := Facteur^tds;
end
}

#ast {
do
   Facteur^ast := Facteur^factory.createSecond(Facteur1^ast);
end
}


--TABLEAUX ET POINTEURS
Facteur -> multiplication #tds Facteur #ast ;
#tds {
do
   Facteur1^tds := Facteur^tds;
end
}

#ast {
do  
   Facteur^ast := Facteur^factory.createPointerAccess(Facteur1^ast);  
end
}

Facteur -> adresse #tds Affectable #ast ;
#tds {
do
   Affectable^tds := Facteur^tds;
end
}

#ast {
do  
   Facteur^ast := Facteur^factory.createAddressAccess(Affectable^ast);  
end  
}

Facteur -> nouveau #tds Type #inh SuiteNouveau #ast ; 
#tds {
do
   Type^tds := Facteur^tds;
   SuiteNouveau^tds := Facteur^tds;
end
}

#inh {
do 
   SuiteNouveau^type := Type^ast; 
end 
}

#ast {
do 
   Facteur^ast := SuiteNouveau^ast; 
end 
}

SuiteNouveau -> crochet_ouvrant #tds Expression crochet_fermant #ast ;
#tds {
do
   Expression^tds := SuiteNouveau^tds;
end
}

#ast {
do  
   SuiteNouveau^ast := SuiteNouveau^factory.createArrayAllocation(SuiteNouveau^type,Expression^ast);  
end  
}

SuiteNouveau -> #ast ; 
#ast {
do 
   SuiteNouveau^ast := SuiteNouveau^factory.createPointerAllocation(SuiteNouveau^type); 
end 
}

Acces -> crochet_ouvrant #tds Expression crochet_fermant #inh Acces #ast;

#tds {
do
   Acces1^tds := Acces^tds;
   Expression^tds := Acces^tds;
end
}

#inh {
do
   Acces1^support := Acces^factory.createArrayAccess(Acces^support,Expression^ast);
end
}

#ast { 
do  
   Acces^ast := Acces1^ast;  
end  
}

--Affectation
Affectable -> parenthese_ouvrante #tds Affectable parenthese_fermante #ast ;

#tds {
do
   Affectable1^tds := Affectable^tds;
end
}

#ast {
do
   Affectable^ast := Affectable1^ast;
end
}

Affectable -> multiplication #tds Affectable #ast ;

#tds {
do
   Affectable1^tds := Affectable^tds;
end
}

#ast {
do
   Affectable^ast := Affectable^factory.createPointerAssignment(Affectable1^ast);
end
}

SuiteAffectable -> crochet_ouvrant #tds Expression crochet_fermant #inh SuiteAffectable #ast ;

#tds {
do
   Expression^tds := SuiteAffectable^tds;
   SuiteAffectable1^tds := SuiteAffectable^tds;
end
}

#inh {
do
   SuiteAffectable1^support := SuiteAffectable^factory.createArrayAssignment(SuiteAffectable^support,Expression^ast);  
end
}

#ast {
do
   SuiteAffectable^ast := SuiteAffectable1^ast;   
end
}

--Déclaration
Instruction -> Type #inh NomEtendu affectation Expression point_virgule #ast ;
#inh {
do
   Expression^tds := Instruction^tds;
   NomEtendu^type := Type^ast;
end
}

#ast {
local 
   v : VariableDeclaration ; 
do 
   if Instruction^tds.contains(NomEtendu^nom) then 
      error(BLOC_already_defined, NomEtendu^nom); 
   else 
      v := Instruction^factory.createVariableDeclaration(NomEtendu^nom,NomEtendu^ast,Expression^ast); 
      Instruction^tds.register(v);
      Instruction^instr := v; 
   end 
end 
}

NomEtendu -> multiplication #inh NomEtendu #ast ;
#inh {
do 
   NomEtendu1^type := NomEtendu^factory.createPointerType(NomEtendu^type); 
end 
}

#ast {
do 
   NomEtendu^nom := NomEtendu1^nom; 
   NomEtendu^ast := NomEtendu1^ast; 
end 
}

NomEtendu -> parenthese_ouvrante #inh NomEtendu parenthese_fermante #ast ;  
#inh {
do 
   NomEtendu1^type := NomEtendu^type; 
end 
}

#ast {
do 
   NomEtendu^nom := NomEtendu1^nom; 
   NomEtendu^ast := NomEtendu1^ast; 
end 
}

NomEtendu -> identificateur #inh SuiteNomEtendu #ast ;
#inh {
do 
   SuiteNomEtendu^type := NomEtendu^type; 
end 
}

#ast {
do 
   NomEtendu^nom := identificateur^txt; 
   NomEtendu^ast := SuiteNomEtendu^ast; 
end 
}

SuiteNomEtendu -> crochet_ouvrant crochet_fermant #inh SuiteNomEtendu #ast ;  
#inh {
do 
   SuiteNomEtendu1^type := SuiteNomEtendu^factory.createArrayType( SuiteNomEtendu^type ); 
end 
}

#ast {
do 
   SuiteNomEtendu^ast := SuiteNomEtendu1^ast; 
end 
}

SuiteNomEtendu -> #ast;
#ast {
do
   SuiteNomEtendu^ast := SuiteNomEtendu^type;
end
}

--AFFECTER DES STRUCTS

Facteur -> accolade_ouvrante #tds Expressions accolade_fermante #ast ;
#tds {
do
   Expressions^tds := Facteur^tds;
end
}

#ast {
do
   Facteur^ast := Facteur^factory.createSequence( Expressions^expressions );
end
}

Expressions -> #tds Expression SuiteExpressions #ast ;
#tds {
do
   Expression^factory := new BlockFactoryImpl();
   Expression^tds := Expressions^tds;
   SuiteExpressions^tds := Expressions^tds;
end
}

#ast {
do 
   SuiteExpressions^expressions.addFirst(Expression^ast); 
   Expressions^expressions := SuiteExpressions^expressions; 
end 
}

SuiteExpressions -> virgule #tds Expression SuiteExpressions #ast ;
#tds {
do
   Expression^factory := new BlockFactoryImpl();
   Expression^tds := SuiteExpressions^tds;
   SuiteExpressions1^tds := SuiteExpressions^tds;
end
}

#ast {
do 
   SuiteExpressions1^expressions.addFirst(Expression^ast); 
   SuiteExpressions^expressions := SuiteExpressions1^expressions; 
end 
}

SuiteExpressions -> #ast ;
#ast {
do
   SuiteExpressions^expressions := new LinkedList<Expression>();
end
}


end
