----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;


inh gauche	: Expression for SuiteCondition, SuiteTerme, SuiteFacteur;
inh factory	: BlockFactory for Bloc, Instruction,
    		  	       SuiteConditionnelle, Instructions, Expression, Condition,
			       SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur,
			       Type, Valeur, Champ, Affectable, SuiteAffectable, Acces, SuiteNouveau,
			       NomEtendu, SuiteNomEtendu;  

inh tds : SymbolTable for Bloc, Instructions, Instruction, Expression, SuiteConditionnelle,
					Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Type,
					Champs, Champ, Affectable, SuiteAffectable, Expressions, SuiteExpressions, Acces, SuiteNouveau;

inh blocParent	: Block for Instructions;

inh support : Assignable for SuiteAffectable;
syn ast 	: Assignable for SuiteAffectable, Affectable;

inh support : Expression for Acces;
syn ast		: Expression for Acces;

syn expressions : LinkedList<Expression> for Expressions, SuiteExpressions;

inh type : Type for SuiteNouveau, NomEtendu, SuiteNomEtendu;

syn nom : String for NomEtendu;

syn ast		: Block for Programme, Bloc ; 
syn ast		: Expression for Expression, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau;
syn ast		: Type for Type, NomEtendu, SuiteNomEtendu;
syn champ	: FieldDeclaration for Champ ;
syn champs	: LinkedList<FieldDeclaration> for Champs;
syn instr	: Instruction for Instruction ;

syn bin_op	: BinaryOperator for Additif, Multiplicatif, Comparatif;

syn suite_cond_bloc : Block for SuiteConditionnelle;

space  separateur				is    "[\n\r\t ]+";
space  commentaire			is    "\/\/.*\n";
sugar  accolade_ouvrante		is    "\{";  
sugar  accolade_fermante		is    "\}";  
sugar  crochet_ouvrant			is    "\[";  
sugar  crochet_fermant			is    "\]";  
sugar  parenthese_ouvrante		is    "\(";
sugar  parenthese_fermante		is    "\)";
sugar  inferieur				is    "\<";  
sugar  superieur				is    "\>";  
sugar  inferieur_egal			is    "\<=";  
sugar  superieur_egal			is    "\>=";  
sugar  point					is    "\.";  
sugar  point_virgule			is    ";";  
sugar  virgule					is    ",";
sugar  affectation				is    "=";
sugar  egalite					is    "==";  
sugar  different				is    "\!=";  
sugar  addition				is    "\+";
sugar  soustraction				is    "\-";
sugar  ou						is    "\|\|";  
sugar  multiplication			is    "\*";
sugar  division				is    "/";
sugar  modulo					is    "%";
sugar  adresse					is    "&";  
sugar  negation				is    "\!";  
sugar  et						is    "&&";  
sugar  vrai					is    "true";
sugar  faux					is    "false";
sugar  si						is    "if";
sugar  sinon					is    "else";
sugar  afficher					is    "print";  
sugar  nouveau				is    "new";  
sugar  tant_que				is    "while";  
sugar  retour					is    "return";  
sugar  type_int				is    "int";
sugar  type_bool				is    "boolean";  
sugar  type_float				is    "float";  
sugar  type_char				is    "char";        
sugar  type_String				is    "String";        
sugar vide					is    "void";     
sugar nul						is    "null";     
sugar  choix					is    "\?";         
sugar  deux_points				is    ":";          
sugar  interface				is    "interface";     
sugar  classe					is    "class";      
sugar  extension				is    "extends";      
sugar  implantation				is    "implements";      
sugar public					is    "public";    
sugar protege					is    "protected";    
sugar prive					is    "private";     
sugar statique					is    "static";       
sugar final					is    "final";       
sugar principale				is    "main";  
term   chaine					is    "\"([^\"]|\\\")*\"";  
term   caractere				is    "\'[^\']\'";  
term   entier					is    "[0-9]+";
term   identificateur			is    "[a-z_][a-zA-Z0-9_]*"; 
term   identificateur_type		is    "[A-Z][a-zA-Z0-9_]*"; 


Programme -> Interfaces Classes Principale ;


Interfaces -> Interface Interfaces ;

Interfaces -> ;


Interface -> interface identificateur_type Genericite HeritageInterface accolade_ouvrante ElementsInterface accolade_fermante ;


HeritageInterface -> extension identificateur_type InstanceGenericite SuiteHeritageInterface ;

HeritageInterface -> ;


SuiteHeritageInterface -> virgule identificateur_type InstanceGenericite SuiteHeritageInterface ;

SuiteHeritageInterface -> ;


ElementsInterface -> ElementInterface ElementsInterface ;

ElementsInterface -> ;


ElementInterface -> final statique Type identificateur affectation Expression point_virgule ;

ElementInterface -> Signature point_virgule ;


Signature -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante ;  
 
Signature -> Type identificateur parenthese_ouvrante Parametres parenthese_fermante ;  


Classes -> Classe Classes ;

Classes -> ;


Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante ElementsClasse accolade_fermante ;


HeritageClasse -> extension identificateur_type InstanceGenericite ;

HeritageClasse -> ;

ImplantationInterface -> implantation identificateur_type InstanceGenericite SuiteHeritageInterface ;

ImplantationInterface -> ;


Principale -> public classe identificateur_type accolade_ouvrante MethodePrincipale accolade_fermante ;


MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante Bloc ;


Genericite -> inferieur ParametresGenericite superieur ;

Genericite -> ;


ParametresGenericite -> ParametreGenericite SuiteParametresGenericite ;


SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite ;

SuiteParametresGenericite -> ;


ParametreGenericite -> identificateur_type HeritageGenericite ;  
 
ParametreGenericite -> choix HeritageGenericite ;  
 

HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite ;

HeritageGenericite -> ;

SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite ;

SuiteHeritageGenericite -> ;


InstanceGenericite -> ;

InstanceGenericite -> inferieur ArgumentsGenericite superieur ;


ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite ;


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite ;

SuiteArgumentsGenericite -> ;


ArgumentGenericite -> identificateur_type InstanceGenericite ;

ArgumentGenericite -> type_String ;


ElementsClasse -> DroitAcces ElementClasse ElementsClasse ;
  
ElementsClasse -> ;  
 

DroitAcces -> public ;  
 
DroitAcces -> protege ;  
 
DroitAcces -> prive ;  
 

ElementClasse -> statique AttributOuMethode ;  
 
ElementClasse -> AttributOuMethode ;
 
ElementClasse -> Constructeur ;  
   

AttributOuMethode -> Type identificateur SuiteAttributOuMethode;

AttributOuMethode -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante Bloc ;


SuiteAttributOuMethode -> point_virgule ;

SuiteAttributOuMethode -> parenthese_ouvrante Parametres parenthese_fermante Bloc ;


Constructeur -> identificateur_type parenthese_ouvrante Parametres parenthese_fermante Bloc ;
 


Parametres -> ;

Parametres -> Parametre SuiteParametres ;


Parametre -> Type identificateur ;


SuiteParametres -> ;

SuiteParametres -> virgule Parametre SuiteParametres ;


Bloc -> accolade_ouvrante  #ast Instructions accolade_fermante  ;
#ast {
local
	b : Block;
do
	b := Bloc^factory.createBlock();
	Bloc^ast := b;
	
	Instructions^blocParent := b;
	Instructions^tds := new SymbolTable(Bloc^tds);
end
}

Type -> TypeAtomique SuiteTypeAtomique ;


TypeAtomique -> type_bool  #ast;
#ast {
do
   TypeAtomique^ast := Type^factory.createBooleanType();  
end
}

TypeAtomique -> type_int   #ast;
#ast {
do
   TypeAtomique^ast := Type^factory.createIntegerType();  
end
}
 
TypeAtomique -> type_char  #ast;
#ast {
do
   TypeAtomique^ast := Type^factory.createCharType();  
end
}
 
TypeAtomique -> type_float  #ast;

TypeAtomique -> type_String #ast;
 
TypeAtomique -> identificateur_type InstanceGenericite  #ast; 


SuiteTypeAtomique -> crochet_ouvrant crochet_fermant SuiteTypeAtomique ;

SuiteTypeAtomique -> ;


Instructions -> ;

Instructions -> #inh Instruction #ast Instructions ;
#inh {
do
	Instruction^factory := new BlockFactoryImpl();
	
	Instructions1^tds := Instructions^tds;
	Instruction^tds := Instructions^tds;
end
}

#ast {
do
	Instructions^blocParent.add(Instruction^instr);
end
}


Instruction -> Type identificateur affectation Expression point_virgule ;


Instruction -> Affectable affectation Expression point_virgule ;


Affectable -> parenthese_ouvrante Affectable parenthese_fermante ;

Affectable -> identificateur SuiteAffectable ;


SuiteAffectable -> ;

SuiteAffectable -> point identificateur AppelOuAcces ;

SuiteAffectable -> crochet_ouvrant Expression crochet_fermant SuiteAffectable ;



Instruction -> si parenthese_ouvrante Expression parenthese_fermante Bloc SuiteConditionnelle ;


SuiteConditionnelle -> ;

SuiteConditionnelle ->sinon Bloc ;

Instruction -> tant_que parenthese_ouvrante Expression parenthese_fermante Bloc ;

Instruction -> afficher Expression point_virgule ;

Instruction -> retour Expression point_virgule ;


Expression -> #tds Condition #inh SuiteCondition #ast;
#tds {
do
	Condition^tds := Expression^tds;
	SuiteCondition^tds := Expression^tds;
end
}

#inh {
do
   SuiteCondition^gauche := Condition^ast ;
end 
}
#ast {
do
    Expression^ast := SuiteCondition^ast;
end 
}

SuiteCondition -> #tds Comparatif Condition #ast ;
#tds {
do
	Condition^tds := SuiteCondition^tds;
end
}

#ast {
do
	SuiteCondition^ast :=
	SuiteCondition^factory.createBinaryExpression(
	SuiteCondition^gauche,
	Comparatif^bin_op,
	Condition^ast);
end 
}

SuiteCondition -> #ast ;
#ast {
do
   SuiteCondition^ast := SuiteCondition^gauche;
end 
}


Comparatif -> egalite #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Equals;
end
}

Comparatif -> different #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.Different;   
end  
}
  
Comparatif -> inferieur #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.Lesser;   
end  
}
  
Comparatif -> inferieur_egal #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.LesserOrEqual;   
end  
}
  
Comparatif -> superieur #texte;  
#texte {   
do  
   Comparatif^bin_op := BinaryOperator.Greater;    
end  
}
   
Comparatif -> superieur_egal #texte;  
#texte {   
do  
   Comparatif^bin_op := BinaryOperator.GreaterOrEqual;    
end  
}

Condition -> #tds Terme #ast_inh SuiteTerme #ast_syn ;
#tds {
do
	Terme^tds := Condition^tds;
	SuiteTerme^tds := Condition^tds;
end
}

#ast_inh {
do 
   SuiteTerme^gauche := Terme^ast; 
end 
}

#ast_syn {
do
   Condition^ast := SuiteTerme^ast; 
end
}

SuiteTerme -> Additif #tds Terme #ast_inh SuiteTerme #ast_syn ;
#tds {
do
	SuiteTerme1^tds := SuiteTerme^tds;
	Terme^tds := SuiteTerme^tds;
end
}

#ast_inh {
do
   SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
      SuiteTerme^gauche,  
      Additif^bin_op,  
      Terme^ast);  
end 
}

#ast_syn {
do 
   SuiteTerme^ast := SuiteTerme1^ast; 
end 
}

SuiteTerme -> #ast ;
#ast {
do
   SuiteTerme^ast := SuiteTerme^gauche;
end
}

Additif -> addition #ast;  
#ast { 
do  
   Additif^bin_op := BinaryOperator.Add;  
end  
}

Additif -> soustraction #ast;  
#ast {  
do  
   Additif^bin_op := BinaryOperator.Substract;   
end  
}
   
Additif -> ou #ast;  
#ast {  
do  
   Additif^bin_op := BinaryOperator.Or;   
end  
}
  
Terme -> #tds Facteur #ast_inh SuiteFacteur #ast_syn ;
#tds {
do
	Facteur^tds := Terme^tds;
	SuiteFacteur^tds := Terme^tds;
end
}
#ast_inh {
do 
   SuiteFacteur^gauche := Facteur^ast; 
end 
}

#ast_syn {
do
   Terme^ast := SuiteFacteur^ast; 
end
}

SuiteFacteur -> Multiplicatif #tds Facteur #ast_inh SuiteFacteur #ast_syn ;
#tds {
do
	Facteur^tds := SuiteFacteur^tds;
	SuiteFacteur1^tds := SuiteFacteur^tds;
end
}

#ast_inh {
do 
   SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
      SuiteFacteur^gauche,  
      Multiplicatif^bin_op,  
      Facteur^ast);  
end 
}

#ast_syn {
do 
   SuiteFacteur^ast := SuiteFacteur1^ast; 
end 
}
 
SuiteFacteur -> #ast;  
#ast {
do
   SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

Multiplicatif -> multiplication #ast; 
#ast {
do 
   Multiplicatif^bin_op := BinaryOperator.Multiply; 
end 
}

Multiplicatif -> division #ast; 
#ast { 
do 
   Multiplicatif^bin_op := BinaryOperator.Divide;  
end 
}
 
Multiplicatif -> modulo #ast; 
#ast {  
do 
   Multiplicatif^bin_op := BinaryOperator.Modulo;   
end 
}
  
Multiplicatif -> et #ast; 
#ast {  
do 
   Multiplicatif^bin_op := BinaryOperator.And;   
end 
}

  
Facteur -> accolade_ouvrante #tds Expressions accolade_fermante #ast;
#tds {
do
	Expression^tds := Facteur^tds;
end
}
#ast { 
do  
   Facteur^ast := Expression^ast;  
end  
}

Expressions -> Expression SuiteExpressions ;

SuiteExpressions -> virgule Expression SuiteExpressions ;

SuiteExpressions -> ;


Facteur -> soustraction Facteur ;  

Facteur -> negation Facteur ;  

Facteur -> nouveau Type SuiteNouveau ;


SuiteNouveau -> crochet_ouvrant Expression crochet_fermant ;

SuiteNouveau -> ;


Facteur -> Valeur #ast;
#ast {
do
   Facteur^ast := Valeur^ast;
end
}

 
Valeur -> entier ;

Valeur -> vrai ;

Valeur -> faux ;

Valeur -> chaine ;

Valeur -> caractere ;


Facteur -> identificateur AppelOuAcces ;


AppelOuAcces -> Acces ;

AppelOuAcces -> Appel ;


Acces -> ;

Acces -> crochet_ouvrant Expression crochet_fermant Acces ;

Acces -> point identificateur AppelOuAcces ;


Appel -> parenthese_ouvrante parenthese_fermante Acces ;  
 
Appel -> parenthese_ouvrante Expressions parenthese_fermante Acces ;  
 
end
