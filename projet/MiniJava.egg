----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;

inh gauche	: Expression for SuiteCondition, SuiteTerme, SuiteFacteur;
inh factory	: BlockFactory for Bloc, Instruction,
			  		   SuiteConditionnelle, Instructions, Expression, Condition,
				   SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur,
				   Type, Valeur, Champ, Affectable, SuiteAffectable, Acces, SuiteNouveau,
				   NomEtendu, SuiteNomEtendu;  

inh tds : SymbolTable for Bloc, Instructions, Instruction, Expression, SuiteConditionnelle,
					Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Type,
					Champs, Champ, Affectable, SuiteAffectable, Expressions, SuiteExpressions,
                    Appel, Acces, AppelOuAcces, SuiteNouveau;

inh blocParent	: Block for Instructions;

inh support : Assignable for SuiteAffectable;
syn ast 	: Assignable for SuiteAffectable, Affectable;

inh support : Expression for Acces;
syn ast		: Expression for Acces;

syn expressions : LinkedList<Expression> for Expressions, SuiteExpressions;

inh type : Type for SuiteNouveau, NomEtendu, SuiteNomEtendu;

syn nom : String for NomEtendu;

syn ast		: Block for Programme, Bloc ; 
syn ast		: Expression for Expression, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau;
syn ast		: Type for Type, NomEtendu, SuiteNomEtendu;
syn champ	: FieldDeclaration for Champ ;
syn champs	: LinkedList<FieldDeclaration> for Champs;
syn instr	: Instruction for Instruction ;

syn bin_op	: BinaryOperator for Additif, Multiplicatif, Comparatif;

syn suite_cond_bloc : Block for SuiteConditionnelle;

space  separateur				is    "[\n\r\t ]+";
space  commentaire			is    "\/\/.*\n";
sugar  accolade_ouvrante		is    "\{";  
sugar  accolade_fermante		is    "\}";  
sugar  crochet_ouvrant			is    "\[";  
sugar  crochet_fermant			is    "\]";  
sugar  parenthese_ouvrante		is    "\(";
sugar  parenthese_fermante		is    "\)";
sugar  inferieur				is    "\<";  
sugar  superieur				is    "\>";  
sugar  inferieur_egal			is    "\<=";  
sugar  superieur_egal			is    "\>=";  
sugar  point					is    "\.";  
sugar  point_virgule			is    ";";  
sugar  virgule					is    ",";
sugar  affectation				is    "=";
sugar  egalite					is    "==";  
sugar  different				is    "\!=";  
sugar  addition				is    "\+";
sugar  soustraction				is    "\-";
sugar  ou						is    "\|\|";  
sugar  multiplication			is    "\*";
sugar  division				is    "/";
sugar  modulo					is    "%";
sugar  adresse					is    "&";  
sugar  negation				is    "\!";  
sugar  et						is    "&&";  
sugar  vrai					is    "true";
sugar  faux					is    "false";
sugar  si						is    "if";
sugar  sinon					is    "else";
sugar  afficher					is    "print";  
sugar  nouveau				is    "new";  
sugar  tant_que				is    "while";  
sugar  retour					is    "return";  
sugar  type_int				is    "int";
sugar  type_bool				is    "boolean";  
sugar  type_float				is    "float";  
sugar  type_char				is    "char";        
sugar  type_String				is    "String";        
sugar vide					is    "void";     
sugar nul						is    "null";     
sugar  choix					is    "\?";         
sugar  deux_points				is    ":";          
sugar  interface				is    "interface";     
sugar  classe					is    "class";      
sugar  extension				is    "extends";      
sugar  implantation				is    "implements";      
sugar public					is    "public";    
sugar protege					is    "protected";    
sugar prive					is    "private";     
sugar statique					is    "static";       
sugar final					is    "final";       
sugar principale				is    "main";  
term   chaine					is    "\"([^\"]|\\\")*\"";  
term   caractere				is    "\'[^\']\'";  
term   entier					is    "[0-9]+";
term   identificateur			is    "[a-z_][a-zA-Z0-9_]*"; 
term   identificateur_type		is    "[A-Z][a-zA-Z0-9_]*"; 


Programme -> Interfaces Classes Principale ;


Interfaces -> Interface Interfaces ;

Interfaces -> ;


Interface -> interface identificateur_type Genericite HeritageInterface accolade_ouvrante ElementsInterface accolade_fermante ;


HeritageInterface -> extension identificateur_type InstanceGenericite SuiteHeritageInterface ;

HeritageInterface -> ;


SuiteHeritageInterface -> virgule identificateur_type InstanceGenericite SuiteHeritageInterface ;

SuiteHeritageInterface -> ;


ElementsInterface -> ElementInterface ElementsInterface ;

ElementsInterface -> ;


ElementInterface -> final statique Type identificateur affectation Expression point_virgule ;

ElementInterface -> Signature point_virgule ;


Signature -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante ;  
 
Signature -> Type identificateur parenthese_ouvrante Parametres parenthese_fermante ;  


Classes -> Classe Classes ;

Classes -> ;


Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante ElementsClasse accolade_fermante ;


HeritageClasse -> extension identificateur_type InstanceGenericite ;

HeritageClasse -> ;

ImplantationInterface -> implantation identificateur_type InstanceGenericite SuiteHeritageInterface ;

ImplantationInterface -> ;


Principale -> public classe identificateur_type accolade_ouvrante MethodePrincipale accolade_fermante ;


MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante Bloc ;


Genericite -> inferieur ParametresGenericite superieur ;

Genericite -> ;


ParametresGenericite -> ParametreGenericite SuiteParametresGenericite ;


SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite ;

SuiteParametresGenericite -> ;


ParametreGenericite -> identificateur_type HeritageGenericite ;  
 
ParametreGenericite -> choix HeritageGenericite ;  
 

HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite ;

HeritageGenericite -> ;

SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite ;

SuiteHeritageGenericite -> ;


InstanceGenericite -> ;

InstanceGenericite -> inferieur ArgumentsGenericite superieur ;


ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite ;


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite ;

SuiteArgumentsGenericite -> ;


ArgumentGenericite -> identificateur_type InstanceGenericite ;

ArgumentGenericite -> type_String ;


ElementsClasse -> DroitAcces ElementClasse ElementsClasse ;
  
ElementsClasse -> ;  
 

DroitAcces -> public ;  
 
DroitAcces -> protege ;  
 
DroitAcces -> prive ;  
 

ElementClasse -> statique AttributOuMethode ;  
 
ElementClasse -> AttributOuMethode ;
 
ElementClasse -> Constructeur ;  
   

AttributOuMethode -> Type identificateur SuiteAttributOuMethode;

AttributOuMethode -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante Bloc ;


SuiteAttributOuMethode -> point_virgule ;

SuiteAttributOuMethode -> parenthese_ouvrante Parametres parenthese_fermante Bloc ;


Constructeur -> identificateur_type parenthese_ouvrante Parametres parenthese_fermante Bloc ;
 


Parametres -> ;

Parametres -> Parametre SuiteParametres ;


Parametre -> Type identificateur ;


SuiteParametres -> ;

SuiteParametres -> virgule Parametre SuiteParametres ;


Bloc -> accolade_ouvrante #ast Instructions accolade_fermante  ;
#ast {
local
    b : Block;
do
    b := Bloc^factory.createBlock();
    Bloc^ast := b;
    
    Instructions^blocParent := b;
    Instructions^tds := new SymbolTable(Bloc^tds);
end
}


Type -> TypeAtomique SuiteTypeAtomique ;


TypeAtomique -> type_bool  ;

TypeAtomique -> type_int   ;  
 
TypeAtomique -> type_char  ;  
 
TypeAtomique -> type_float  ;

TypeAtomique -> type_String ;
 
TypeAtomique -> identificateur_type InstanceGenericite  ; 


SuiteTypeAtomique -> crochet_ouvrant crochet_fermant SuiteTypeAtomique ;

SuiteTypeAtomique -> ;


Instructions -> ;

Instructions -> #inh Instruction #instr Instructions ;
#inh {
do
    Instruction^factory := new BlockFactoryImpl();
    
    Instruction^tds := Instructions^tds;
    Instructions1^tds := Instructions^tds;
end
}

#instr {
do
    Instructions^blocParent.add(Instruction^instr);
end
}


Instruction -> Type identificateur affectation #tds Expression point_virgule #instr ;
#tds {
do
    Expression^tds := Instruction^tds;
end
}

#instr {
local
	d : VariableDeclaration;
do
	if Instruction^tds.contains(identificateur^txt) then
		error(Error);
	else
		d := Instruction^factory.createVariableDeclaration(identificateur^txt, Type^ast, Expression^ast);
		
		Instruction^tds.register(d);
		Instruction^instr := d;
	end
end
}


Instruction -> #tds Affectable affectation Expression #instr point_virgule ;
#tds {
do
    Affectable^tds := Instruction^tds;
    Expression^tds := Instruction^tds;
end
}

#instr {
do
    Instruction^instr := Instruction^factory.createAssignment(Affectable^ast, Expression^ast);
end
}

Affectable -> parenthese_ouvrante #tds Affectable parenthese_fermante #ast ;

#tds {
do
    Affectable1^tds := Affectable^tds;
end
}

#ast {
do
    Affectable^ast := Affectable1^ast;
end
}

Affectable -> identificateur #tds #inh SuiteAffectable #ast ;
#tds {
do
    SuiteAffectable^tds := Affectable^tds;
end
}

#inh {
local
    o : Optional<Declaration>;
    d : Declaration;
do
    if (Affectable^tds.knows(identificateur^txt)) then
        o := Affectable^tds.get(identificateur^txt);
        d := o.get();
        match d
        with VariableDeclaration then SuiteAffectable^support := Affectable^factory.createVariableAssignment( d );
        with ConstantDeclaration then error(BLOC_not_a_variable, identificateur^txt);
        end
    else
        error(BLOC_undefined_ident, identificateur^txt);
    end
end
}

#ast {
do
    Affectable^ast := SuiteAffectable^ast;
end
}


SuiteAffectable -> #ast ;
#ast { 
do  
    SuiteAffectable^ast := SuiteAffectable^support;  
end  
}

SuiteAffectable -> point identificateur #tds AppelOuAcces ;
#tds {
do
    AppelOuAcces^tds := SuiteAffectable^tds;
end
}

SuiteAffectable -> crochet_ouvrant #tds Expression crochet_fermant #inh SuiteAffectable #ast ;
#tds {
do
    Expression^tds := SuiteAffectable^tds;
    SuiteAffectable1^tds := SuiteAffectable^tds;
end
}

#inh {
do
    SuiteAffectable1^support := SuiteAffectable^factory.createArrayAssignment(SuiteAffectable^support,Expression^ast);  
end
}

#ast {
do
    SuiteAffectable^ast := SuiteAffectable1^ast;   
end
}


Instruction -> si parenthese_ouvrante #tds Expression parenthese_fermante Bloc SuiteConditionnelle #instr ;
#tds {
do
    Expression^tds := Instruction^tds;
    SuiteConditionnelle^tds := Instruction^tds;
    
    Bloc^tds := new SymbolTable(Instruction^tds);
end
}

#instr {
local
    sc_bloc : Block;
do
    sc_bloc := SuiteConditionnelle^suite_cond_bloc;
    
    if sc_bloc = null then
        Instruction^instr := Instruction^factory.createConditional(Expression^ast, Bloc^ast);
    else
        Instruction^instr := Instruction^factory.createConditional(Expression^ast, Bloc^ast, sc_bloc);
    end
end
}


SuiteConditionnelle -> #suite_cond_bloc ;
#suite_cond_bloc {
do
    SuiteConditionnelle^suite_cond_bloc := null;
end
}

SuiteConditionnelle -> sinon #tds Bloc #suite_cond_bloc ;
#tds {
do
    Bloc^tds := new SymbolTable(SuiteConditionnelle^tds);
end
}

#suite_cond_bloc {
do
    SuiteConditionnelle^suite_cond_bloc := Bloc^ast;
end
}

Instruction -> tant_que parenthese_ouvrante #tds Expression parenthese_fermante Bloc #instr ;
#tds {
do
    Expression^tds := Instruction^tds;
    Bloc^tds := new SymbolTable(Instruction^tds);
end
}

#instr {
do
    Instruction^instr := Instruction^factory.createRepetition(Expression^ast, Bloc^ast);
end
}


Instruction -> afficher Expression point_virgule #instr ;
#instr {
do
    Instruction^instr := Instruction^factory.createPrinter(Expression^ast);
end
}

Instruction -> retour Expression point_virgule ;


Expression -> #tds Condition #inh SuiteCondition #ast ;
#tds {
do
    Condition^tds := Expression^tds;
    SuiteCondition^tds := Expression^tds;
end
}

#inh {
do
    SuiteCondition^gauche := Condition^ast;
end 
}

#ast {
do
    Expression^ast := SuiteCondition^ast;
end 
}


SuiteCondition -> #tds Comparatif Condition #ast ;
#tds {
do
    Condition^tds := SuiteCondition^tds;
end
}

#ast {
do
    SuiteCondition^ast :=
    SuiteCondition^factory.createBinaryExpression(
        SuiteCondition^gauche,
        Comparatif^bin_op,
        Condition^ast);
end 
}

SuiteCondition -> #ast ;
#ast {
do
    SuiteCondition^ast := SuiteCondition^gauche;
end 
}


Comparatif -> egalite #texte ;
#texte {
do
    Comparatif^bin_op := BinaryOperator.Equals;
end
}

Comparatif -> different #texte ;
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Different;   
end  
}

Comparatif -> inferieur #texte ;
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Lesser;   
end  
}

Comparatif -> inferieur_egal #texte ;
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.LesserOrEqual;   
end  
}

Comparatif -> superieur #texte ;
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.Greater;    
end  
}

Comparatif -> superieur_egal #texte ;
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.GreaterOrEqual;    
end  
}

   
Condition -> #tds Terme #ast_inh SuiteTerme #ast_syn ;
#tds {
do
    Terme^tds := Condition^tds;
    SuiteTerme^tds := Condition^tds;
end
}

#ast_inh {
do 
    SuiteTerme^gauche := Terme^ast; 
end 
}

#ast_syn {
do
    Condition^ast := SuiteTerme^ast; 
end
}


SuiteTerme -> Additif #tds Terme #ast_inh SuiteTerme #ast_syn ;
#tds {
do
    SuiteTerme1^tds := SuiteTerme^tds;
    Terme^tds := SuiteTerme^tds;
end
}

#ast_inh {
do
    SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
	  SuiteTerme^gauche,  
	  Additif^bin_op,  
	  Terme^ast);  
end 
}

#ast_syn {
do 
    SuiteTerme^ast := SuiteTerme1^ast; 
end 
}

SuiteTerme -> #ast ;
#ast {
do
    SuiteTerme^ast := SuiteTerme^gauche;
end
}

Additif -> addition #ast;  
#ast { 
do  
    Additif^bin_op := BinaryOperator.Add;  
end  
}

Additif -> soustraction #ast;  
#ast {  
do  
    Additif^bin_op := BinaryOperator.Substract;   
end  
}
   
Additif -> ou #ast;  
#ast {  
do
    Additif^bin_op := BinaryOperator.Or;   
end  
}
  
Terme -> #tds Facteur #ast_inh SuiteFacteur #ast_syn ;
#tds {
do
    Facteur^tds := Terme^tds;
    SuiteFacteur^tds := Terme^tds;
end
}
#ast_inh {
do 
    SuiteFacteur^gauche := Facteur^ast; 
end 
}

#ast_syn {
do
    Terme^ast := SuiteFacteur^ast; 
end
}

SuiteFacteur -> Multiplicatif #tds Facteur #ast_inh SuiteFacteur #ast_syn ;
#tds {
do
    Facteur^tds := SuiteFacteur^tds;
    SuiteFacteur1^tds := SuiteFacteur^tds;
end
}

#ast_inh {
do 
    SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
	  SuiteFacteur^gauche,  
	  Multiplicatif^bin_op,  
	  Facteur^ast);  
end 
}

#ast_syn {
do 
    SuiteFacteur^ast := SuiteFacteur1^ast; 
end 
}
 
SuiteFacteur -> #ast;  
#ast {
do
    SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

Multiplicatif -> multiplication #ast; 
#ast {
do 
    Multiplicatif^bin_op := BinaryOperator.Multiply; 
end 
}

Multiplicatif -> division #ast; 
#ast { 
do 
    Multiplicatif^bin_op := BinaryOperator.Divide;  
end 
}
 
Multiplicatif -> modulo #ast; 
#ast {  
do 
    Multiplicatif^bin_op := BinaryOperator.Modulo;   
end 
}
  
Multiplicatif -> et #ast; 
#ast {  
do 
    Multiplicatif^bin_op := BinaryOperator.And;   
end 
}

  
Facteur -> accolade_ouvrante #tds Expressions accolade_fermante #ast ;
#tds {
do
    Expressions^tds := Facteur^tds;
end
}

#ast {
do
    Facteur^ast := Facteur^factory.createSequence( Expressions^expressions );
end
}


Expressions -> #tds Expression SuiteExpressions #ast ;
#tds {
do
    Expression^factory := new BlockFactoryImpl();
    Expression^tds := Expressions^tds;
    SuiteExpressions^tds := Expressions^tds;
end
}

#ast {
do 
    SuiteExpressions^expressions.addFirst(Expression^ast); 
    Expressions^expressions := SuiteExpressions^expressions; 
end 
}

SuiteExpressions -> virgule #tds Expression SuiteExpressions #ast ;
#tds {
do
    Expression^factory := new BlockFactoryImpl();
    Expression^tds := SuiteExpressions^tds;
    SuiteExpressions1^tds := SuiteExpressions^tds;
end
}

#ast {
do 
    SuiteExpressions1^expressions.addFirst(Expression^ast); 
    SuiteExpressions^expressions := SuiteExpressions1^expressions; 
end 
}

SuiteExpressions -> #ast ;
#ast {
do
    SuiteExpressions^expressions := new LinkedList<Expression>();
end
}


Facteur -> soustraction #tds Facteur #ast ;  
#tds {
do
    Facteur1^tds := Facteur^tds;
end
}

#ast { 
do  
    Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);  
end  
}  

Facteur -> negation #tds Facteur #ast ;  
#tds {
do
    Facteur1^tds := Facteur^tds;
end
}

#ast {
do
    Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);  
end
}

Facteur -> nouveau #tds Type #inh SuiteNouveau #ast ; 
#tds {
do
    Type^tds := Facteur^tds;
    SuiteNouveau^tds := Facteur^tds;
end
}

#inh {
do 
    SuiteNouveau^type := Type^ast; 
end 
}

#ast {
do 
    Facteur^ast := SuiteNouveau^ast; 
end 
}


SuiteNouveau -> crochet_ouvrant #tds Expression crochet_fermant #ast ;
#tds {
do
    Expression^tds := SuiteNouveau^tds;
end
}

#ast {
do  
    SuiteNouveau^ast := SuiteNouveau^factory.createArrayAllocation(SuiteNouveau^type,Expression^ast);  
end  
}

SuiteNouveau -> #ast ; 
#ast {
do 
    SuiteNouveau^ast := SuiteNouveau^factory.createPointerAllocation(SuiteNouveau^type); 
end 
}


Facteur -> Valeur #ast;
#ast {
do
    Facteur^ast := Valeur^ast;
end
}

 
Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt); 
end
}

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);  
end
}

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);  
end
}

Valeur -> chaine ;

Valeur -> caractere ;


Facteur -> identificateur #tds AppelOuAcces ;
#tds {
do
    AppelOuAcces^tds := Facteur^tds;
end
}


AppelOuAcces -> #tds Acces ;
#tds {
do
    Acces^tds := AppelOuAcces^tds;
end
}

AppelOuAcces -> #tds Appel ;
#tds {
do
    Appel^tds := AppelOuAcces^tds;
end
}


Acces -> #ast ;
#ast {
do  
    Acces^ast := Acces^support;  
end  
}

Acces -> crochet_ouvrant #tds Expression crochet_fermant #inh Acces #ast;
#tds {
do
    Acces1^tds := Acces^tds;
    Expression^tds := Acces^tds;
end
}

#inh {
do
    Acces1^support := Acces^factory.createArrayAccess(Acces^support,Expression^ast);
end
}

#ast { 
do  
    Acces^ast := Acces1^ast;  
en


Acces -> point identificateur #tds AppelOuAcces ;
#tds {
do
    AppelOuAcces^tds := Acces^tds;
end
}

Appel -> parenthese_ouvrante parenthese_fermante #tds Acces ;
#tds {
do
    Acces^tds := Appel^tds;
end
}
 
Appel -> parenthese_ouvrante Expressions parenthese_fermante #tds Acces ;
#tds {
do
    Acces^tds := Appel^tds;
end
}
 
end
