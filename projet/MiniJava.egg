----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;

inh gauche	: Expression for SuiteCondition, SuiteTerme, SuiteFacteur;
inh factory	: BlockFactory for Bloc, Instruction,
                    SuiteConditionnelle, Instructions, Expression, Condition,
                    SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur,
                    Type, TypeAtomique, Valeur, Affectable, SuiteAffectable,
                    AppelOuAcces, Acces, SuiteNouveau;

inh tds : SymbolTable for Bloc, Instructions, Instruction, Expression, SuiteConditionnelle,
                    Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Type,
                    TypeAtomique, Affectable, SuiteAffectable, Expressions, SuiteExpressions,
                    AppelOuAcces, Acces, SuiteNouveau, Parametres, Parametre, SuiteParametres,
                    Principale, MethodePrincipale,  Interface, ElementsInterface,
                    ElementInterface, Signature, Classes, Classe, ElementsClasse, ElementClasse,
                    Constructeur, AttributOuMethode, SuiteAttributOuMethode, Arguments; --Appel

inh blocParent	: Block for Instructions;

inh support : Assignable for SuiteAffectable;
syn ast 	: Assignable for SuiteAffectable, Affectable;

inh support : Expression for AppelOuAcces, Acces;
syn ast		: Expression for AppelOuAcces, Acces; --, Appel

syn expressions : LinkedList<Expression> for Expressions, SuiteExpressions;

inh type : Type for SuiteNouveau;

--GESTION DES TYPES

inh calcul_profondeur : Integer for SuiteTypeAtomique;
syn profondeur_remontee : Integer for SuiteTypeAtomique;

syn ast : Type for Type, TypeAtomique;


--PROGRAMME ASTS

syn ast     : Program for Programme;

--Principale
syn ast     : ClassePrincipale for Principale;
syn bloc    : Block for MethodePrincipale;

--Interfaces
syn ast        : Interface for Interface;
syn interfaces : LinkedList<Interface> for Interfaces;
inh interface_mere : Interface for ElementsInterface, ElementInterface;

--Signatures d'interfaces
syn type : Optional<Type> for Signature;
syn nom : String for Signature;
syn args : LinkedList<Argument> for Signature;

--Classes
syn ast     : Classe for Classe;
syn classes : LinkedList<Classe> for Classes;
inh classe_mere : Classe for ElementsClasse, ElementClasse;

--Methodes et arguments de classe
syn type            : Optional<Type> for AttributOuMethode;
syn nom             : String for AttributOuMethode;
syn methode_corps   : Block for AttributOuMethode, SuiteAttributOuMethode;
syn methode_arguments : LinkedList<Argument> for AttributOuMethode, SuiteAttributOuMethode;

syn args            : LinkedList<Argument> for Parametres, SuiteParametres;
syn nom             : String for Parametre;
syn type            : Type for Parametre;

inh droit : DroitAcces for ElementClasse;
syn droit : DroitAcces for DroitAcces;

--Constructeur de classe
syn args : LinkedList<Argument> for Constructeur;
syn bloc : Block for Constructeur;
syn args : LinkedList<Expression> for Arguments;

--

syn ast		: Block for Bloc;
syn ast		: Expression for Expression, Condition, SuiteCondition,
    Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau;

syn instr	: Instruction for Instruction;

syn bin_op	: BinaryOperator for Additif, Multiplicatif, Comparatif;

syn suite_cond_bloc : Block for SuiteConditionnelle;

space  separateur				is    "[\n\r\t ]+";
space  commentaire				is    "\/\/.*\n";
sugar  accolade_ouvrante		is    "\{";  
sugar  accolade_fermante		is    "\}";  
sugar  crochet_ouvrant			is    "\[";  
sugar  crochet_fermant			is    "\]";  
sugar  parenthese_ouvrante		is    "\(";
sugar  parenthese_fermante		is    "\)";
sugar  inferieur				is    "\<";  
sugar  superieur				is    "\>";  
sugar  inferieur_egal			is    "\<=";  
sugar  superieur_egal			is    "\>=";  
sugar  point					is    "\.";  
sugar  point_virgule			is    ";";  
sugar  virgule					is    ",";
sugar  affectation				is    "=";
sugar  egalite					is    "==";  
sugar  different				is    "\!=";  
sugar  addition					is    "\+";
sugar  soustraction				is    "\-";
sugar  ou						is    "\|\|";  
sugar  multiplication			is    "\*";
sugar  division					is    "/";
sugar  modulo					is    "%";
sugar  adresse					is    "&";  
sugar  negation					is    "\!";  
sugar  et						is    "&&";  
sugar  vrai						is    "true";
sugar  faux						is    "false";
sugar  si						is    "if";
sugar  sinon					is    "else";
sugar  afficher					is    "print";  
sugar  nouveau					is    "new";  
sugar  tant_que					is    "while";  
sugar  retour					is    "return";  
sugar  type_int					is    "int";
sugar  type_bool				is    "boolean";  
sugar  type_float				is    "float";  
sugar  type_char				is    "char";        
sugar  type_String				is    "String";        
sugar vide						is    "void";     
sugar null						is    "null";     
sugar  choix					is    "\?";         
sugar  deux_points				is    ":";          
sugar  interface				is    "interface";     
sugar  classe					is    "class";      
sugar  extension				is    "extends";      
sugar  implantation				is    "implements";      
sugar public					is    "public";    
sugar protege					is    "protected";    
sugar prive						is    "private";     
sugar statique					is    "static";       
sugar final						is    "final";       
sugar principale				is    "main";  
term   chaine					is    "\"([^\"]|\\\")*\"";  
term   caractere				is    "\'[^\']\'";  
term   entier					is    "[0-9]+";
term   identificateur			is    "[a-z_][a-zA-Z0-9_]*"; 
term   identificateur_type		is    "[A-Z][a-zA-Z0-9_]*"; 


Programme -> Interfaces #tds Classes Principale #ast ;
#tds {
local
    tds : SymbolTable;
do
    tds := new SymbolTable();
    
    Classes^tds := tds;
    Principale^tds := tds;
end
}

#ast {
local
    prg : ProgramFactoryImpl;
do
    prg := new ProgramFactoryImpl();
    
    Collections.reverse(Interfaces^interfaces);
    Collections.reverse(Classes^classes);
    Programme^ast := prg.createProgram(Principale^ast, Interfaces^interfaces, Classes^classes);
end
}


Interfaces -> #tds Interface Interfaces #interfaces ;
#tds {
do
    Interface^tds := new SymbolTable();
end
}

#interfaces {
do
    Interfaces^interfaces := Interfaces1^interfaces;
    Interfaces^interfaces.add(Interface^ast);
end
}

Interfaces -> #interfaces ;
#interfaces {
do
    Interfaces^interfaces := new LinkedList<Interface>();
end
}

Interface -> interface identificateur_type Genericite HeritageInterface accolade_ouvrante #ast_inh ElementsInterface accolade_fermante ;
#ast_inh {
local
    prg : ProgramFactoryImpl;
    interface : Interface;
do
    --AST
    prg := new ProgramFactoryImpl();
    interface := prg.createInterface(identificateur_type^txt);
    
    Interface^ast := interface;
    
    --INH
    ElementsInterface^tds := Interface^tds;
    ElementsInterface^interface_mere := interface;
end
}

HeritageInterface -> extension identificateur_type InstanceGenericite SuiteHeritageInterface ;

HeritageInterface -> ;


SuiteHeritageInterface -> virgule identificateur_type InstanceGenericite SuiteHeritageInterface ;

SuiteHeritageInterface -> ;


ElementsInterface -> #tds #inh ElementInterface ElementsInterface ;
#tds {
do
    ElementInterface^tds := ElementsInterface^tds;
    ElementsInterface1^tds := ElementsInterface^tds;
end
}

#inh {
do
    ElementInterface^interface_mere := ElementsInterface^interface_mere;
    ElementsInterface1^interface_mere := ElementsInterface^interface_mere;
end
}

ElementsInterface -> ;


ElementInterface -> final statique #tds #inh Type identificateur affectation Expression point_virgule ;
#tds {
do
    Type^tds := ElementInterface^tds;
    Expression^tds := ElementInterface^tds;
end
}

#inh {
local
    fac : BlockFactoryImpl;
do
    fac := new BlockFactoryImpl();
    
    Type^factory := fac;
    Expression^factory := fac;
end
}

ElementInterface -> #tds Signature point_virgule #ast ;
#tds {
do
    Signature^tds := ElementInterface^tds;
end
}

#ast {
do
    if (! ElementInterface^interface_mere.ajouterSignature(Signature^type,
                                                        Signature^nom,
                                                        Signature^args)
    ) then
        error(MiniJava_Signature_DejaDef, ElementInterface^interface_mere.getNom(), Signature^nom);
    end
end
}


Signature -> vide identificateur parenthese_ouvrante #tds Parametres parenthese_fermante #ast ;
#tds {
do
    Parametres^tds := Signature^tds;
end
}

#ast {
do
    Signature^type := Optional.empty();
    Signature^nom := identificateur^txt;
    Signature^args := Parametres^args;
end
}
 
Signature -> #tds #inh Type identificateur parenthese_ouvrante Parametres parenthese_fermante #ast ;
#tds {
do
    Type^tds := Signature^tds;
    Parametres^tds := Signature^tds;
end
}

#inh {
do
    Type^factory := new BlockFactoryImpl();
end
}

#ast {
do
    Signature^type := Optional.of(Type^ast);
    Signature^nom := identificateur^txt;
    Signature^args := Parametres^args;
end
}


Classes -> #tds Classe #tds1 Classes #classes ;
#tds {
do
    Classe^tds := Classes^tds;
end
}

#tds1 {
local
    fac : BlockFactoryImpl;
do
    fac := new BlockFactoryImpl();
    
    if Classes^tds.contains(Classe^ast.getNom()) then
        error(MiniJava_classe_already_defined, Classe^ast.getNom());
	else
        Classes1^tds := Classes^tds;
        Classes1^tds.register( fac.createClasseDeclaration(Classe^ast) );
    end
end
}

#classes {
do
    Classes^classes := Classes1^classes;
    Classes^classes.add(Classe^ast);
end
}

Classes -> #classes ;
#classes {
do
    Classes^classes := new LinkedList<Classe>();
end
}


Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante #ast_inh ElementsClasse accolade_fermante ;
#ast_inh {
local
    prg : ProgramFactoryImpl;
    classe : Classe;
do
    --AST
    prg := new ProgramFactoryImpl();
    classe := prg.createClasse(identificateur_type^txt);
    
    Classe^ast := classe;
    
    --INH
    ElementsClasse^tds := Classe^tds;
    ElementsClasse^classe_mere := classe;
end
}

HeritageClasse -> extension identificateur_type InstanceGenericite ;

HeritageClasse -> ;

ImplantationInterface -> implantation identificateur_type InstanceGenericite SuiteHeritageInterface ;

ImplantationInterface -> ;


Principale -> public classe identificateur_type accolade_ouvrante #tds MethodePrincipale accolade_fermante #ast ;
#tds {
do
    MethodePrincipale^tds := Principale^tds;
end
}

#ast {
local
    prg : ProgramFactoryImpl;
do
    prg := new ProgramFactoryImpl();
    Principale^ast := prg.createPrincipale(identificateur_type^txt, MethodePrincipale^bloc);
end
}


MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante #tds Bloc #ast ;
#tds {
do
    Bloc^tds := new SymbolTable(MethodePrincipale^tds);
    Bloc^factory := new BlockFactoryImpl();
end
}

#ast {
do
    MethodePrincipale^bloc := Bloc^ast;
end
}


Genericite -> inferieur ParametresGenericite superieur ;

Genericite -> ;


ParametresGenericite -> ParametreGenericite SuiteParametresGenericite ;


SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite ;

SuiteParametresGenericite -> ;


ParametreGenericite -> identificateur_type HeritageGenericite ;  
 
ParametreGenericite -> choix HeritageGenericite ;  
 

HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite ;

HeritageGenericite -> ;

SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite ;

SuiteHeritageGenericite -> ;


InstanceGenericite -> ;

InstanceGenericite -> inferieur ArgumentsGenericite superieur ;


ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite ;


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite ;

SuiteArgumentsGenericite -> ;


ArgumentGenericite -> identificateur_type InstanceGenericite ;

ArgumentGenericite -> type_String ;


ElementsClasse -> DroitAcces #tds #inh ElementClasse ElementsClasse ;
#tds {
do
    ElementClasse^tds := ElementsClasse^tds;
    ElementsClasse1^tds := ElementsClasse^tds;
end
}

#inh {
do
    ElementClasse^classe_mere := ElementsClasse^classe_mere;
    ElementClasse^droit := DroitAcces^droit;
    
    ElementsClasse1^classe_mere := ElementsClasse^classe_mere;
end
}
  
ElementsClasse -> ;  
 

DroitAcces -> public #droit ;
#droit {
do
    DroitAcces^droit := DroitAcces.PUBLIC;
end
}
 
DroitAcces -> protege #droit ;
#droit {
do
    DroitAcces^droit := DroitAcces.PROTECTED;
end
}

DroitAcces -> prive #droit ;
#droit {
do
    DroitAcces^droit := DroitAcces.PRIVATE;
end
}
 

ElementClasse -> statique #tds AttributOuMethode #ast ;
#tds {
do
    AttributOuMethode^tds := ElementClasse^tds;
end
}

#ast {
local
    prg : ProgramFactoryImpl;
do
    prg := new ProgramFactoryImpl();
    
    if AttributOuMethode^methode_corps != null then     --UNE METHODE
        
        if (! ElementClasse^classe_mere.ajouterMethode(
            prg.createMethode(AttributOuMethode^nom,
                                AttributOuMethode^methode_arguments,
                                AttributOuMethode^methode_corps,
                                ElementClasse^droit,
                                true,
                                AttributOuMethode^type) )
        ) then
            error(MiniJava_Methode_DejaDef, ElementClasse^classe_mere.getNom(), AttributOuMethode^nom);
        end
    
    else                                                --UN ATTRIBUT
        
        if (! ElementClasse^classe_mere.ajouterAttribut(
            prg.createAttribut(AttributOuMethode^type.get(),
                                AttributOuMethode^nom,
                                ElementClasse^droit,
                                true) )
        ) then
            error(MiniJava_Attribut_DejaDef, ElementClasse^classe_mere.getNom(), AttributOuMethode^nom);
        end
    
    end
end
}
 
ElementClasse -> #tds AttributOuMethode #ast ;
#tds {
do
    AttributOuMethode^tds := ElementClasse^tds;
end
}

#ast {
local
    prg : ProgramFactoryImpl;
do
    prg := new ProgramFactoryImpl();
    
    if AttributOuMethode^methode_corps != null then     --UNE METHODE
        
        if (! ElementClasse^classe_mere.ajouterMethode(
            prg.createMethode(AttributOuMethode^nom,
                                AttributOuMethode^methode_arguments,
                                AttributOuMethode^methode_corps,
                                ElementClasse^droit,
                                false,
                                AttributOuMethode^type) )
        ) then
            error(MiniJava_Methode_DejaDef, ElementClasse^classe_mere.getNom(), AttributOuMethode^nom);
        end
    
    else                                                --UN ATTRIBUT
        
        if (! ElementClasse^classe_mere.ajouterAttribut(
            prg.createAttribut(AttributOuMethode^type.get(),
                                AttributOuMethode^nom,
                                ElementClasse^droit,
                                false) )
        ) then
            error(MiniJava_Attribut_DejaDef, ElementClasse^classe_mere.getNom(), AttributOuMethode^nom);
        end
    
    end
end
}
 
ElementClasse -> #tds Constructeur #ast ;
#tds {
do
    Constructeur^tds := ElementClasse^tds;
end
}

#ast {
local
    prg : ProgramFactoryImpl;
do
    prg := new ProgramFactoryImpl();
    
    if (! ElementClasse^classe_mere.ajouterConstructeur(
        prg.createConstructeur(ElementClasse^classe_mere,
                                ElementClasse^droit,
                                Constructeur^args,
                                Constructeur^bloc) )
    ) then
        error(MiniJava_Constructeur_DejaDef, ElementClasse^classe_mere.getNom());
    end
end
}

AttributOuMethode -> #tds #inh Type identificateur SuiteAttributOuMethode #ast ;
#tds {
do
    Type^tds := AttributOuMethode^tds;
end
}

#inh {
do
    Type^factory := new BlockFactoryImpl();
end
}

#ast {
do
    AttributOuMethode^type := Optional.of(Type^ast);
    AttributOuMethode^nom := identificateur^txt;
    AttributOuMethode^methode_corps := SuiteAttributOuMethode^methode_corps; --null si c'est un attribut
    AttributOuMethode^methode_arguments := SuiteAttributOuMethode^methode_arguments; --null si c'est un attribut
end
}

AttributOuMethode -> vide identificateur parenthese_ouvrante #tds Parametres parenthese_fermante #inh Bloc #ast ;
#tds {
do
    Parametres^tds := AttributOuMethode^tds;
    Bloc^tds := new SymbolTable(AttributOuMethode^tds);
end
}

#inh {
do
    Bloc^factory := new BlockFactoryImpl();
end
}

#ast {
do
    AttributOuMethode^type := Optional.empty();
    AttributOuMethode^nom := identificateur^txt;
    AttributOuMethode^methode_corps := Bloc^ast;
    AttributOuMethode^methode_arguments := Parametres^args;
end
}


SuiteAttributOuMethode -> point_virgule #ast ;
#ast {
do
    SuiteAttributOuMethode^methode_corps := null;     --C'est un attribut.
    SuiteAttributOuMethode^methode_arguments := null; --C'est un attribut.
end
}

SuiteAttributOuMethode -> parenthese_ouvrante #tds Parametres parenthese_fermante #inh Bloc #ast ;
#tds {
do
    Parametres^tds := SuiteAttributOuMethode^tds;
    Bloc^tds := new SymbolTable(SuiteAttributOuMethode^tds);
end
}

#inh {
do
    Bloc^factory := new BlockFactoryImpl();
end
}

#ast {
do
    SuiteAttributOuMethode^methode_corps := Bloc^ast;
    SuiteAttributOuMethode^methode_arguments := Parametres^args;
end
}


Constructeur -> identificateur_type parenthese_ouvrante #tds Parametres parenthese_fermante #inh Bloc #ast ;
#tds {
do
    Parametres^tds := Constructeur^tds;
    Bloc^tds := new SymbolTable(Constructeur^tds);
end
}

#inh {
do
    Bloc^factory := new BlockFactoryImpl();
end
}

#ast {
do
    Constructeur^args := Parametres^args;
    Constructeur^bloc := Bloc^ast;
end
}


Parametres -> #args ;
#args {
do
    Parametres^args := new LinkedList<Argument>();
end
}

Parametres -> #tds Parametre SuiteParametres #args ;
#tds {
do
    Parametre^tds := Parametres^tds;
    SuiteParametres^tds := Parametres^tds;
end
}

#args {
local
    prg : ProgramFactoryImpl;
    liste_args : LinkedList<Argument>;
do
    prg := new ProgramFactoryImpl();
    
    liste_args := new LinkedList<Argument>();
    liste_args.add( prg.createArgument(Parametre^type, Parametre^nom) );
    liste_args.addAll( SuiteParametres^args );
    
    Parametres^args := liste_args;
    
    --TESTER ICI SI IL N'Y A PAS DE DOUBLONS
end
}

Parametre -> #tds Type identificateur #ast ;
#tds {
do
    Type^tds := Parametre^tds;
    Type^factory := new BlockFactoryImpl();
end
}

#ast {
do
    Parametre^nom := identificateur^txt;
    Parametre^type := Type^ast;
end
}


SuiteParametres -> #args ;
#args {
do
    SuiteParametres^args := new LinkedList<Argument>();
end
}

SuiteParametres -> virgule #tds Parametre SuiteParametres #args ;
#tds {
do
    Parametre^tds := SuiteParametres^tds;
    SuiteParametres1^tds := SuiteParametres^tds;
end
}

#args {
local
    prg : ProgramFactoryImpl;
    liste_args : LinkedList<Argument>;
do
    prg := new ProgramFactoryImpl();
    
    liste_args := new LinkedList<Argument>();
    liste_args.add( prg.createArgument(Parametre^type, Parametre^nom) );
    liste_args.addAll( SuiteParametres1^args );
    
    SuiteParametres^args := liste_args;
end
}


Bloc -> accolade_ouvrante #ast Instructions accolade_fermante  ;
#ast {
local
    b : Block;
do
    b := Bloc^factory.createBlock();
    Bloc^ast := b;
    
    Instructions^blocParent := b;
    Instructions^tds := new SymbolTable(Bloc^tds);
end
}


Type -> #tds TypeAtomique #calcul_prof SuiteTypeAtomique #ast ;
#tds {
do
    TypeAtomique^tds := Type^tds;
end
}

#calcul_prof {
do
    SuiteTypeAtomique^calcul_profondeur := 0;
end
}

#ast {
do
    --Type^ast := Type^factory.makeTableType(TypeAtomique^ast,
    --                            SuiteTypeAtomique^profondeur_remontee); --A CODER !!!
    
    Type^ast := TypeAtomique^ast;
end
}


TypeAtomique -> type_bool #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createBooleanType();
end
}

TypeAtomique -> type_int #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createIntegerType();
end
} 
 
TypeAtomique -> type_char #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createCharType(); --A CODER ?
end
}
 
TypeAtomique -> type_float #ast ;
#ast {
do
    TypeAtomique^ast :=  TypeAtomique^factory.createFloatingType(); --A CODER ?
end
}

TypeAtomique -> type_String #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createStringType(); --A CODER ?
end
}
 
TypeAtomique -> identificateur_type InstanceGenericite #ast ;
#ast {
local
    f : Optional<Declaration>;
    d : Declaration;
do
    if (TypeAtomique^tds.knows(identificateur_type^txt)) then
        f := TypeAtomique^tds.get(identificateur_type^txt);
        d := f.get();
        match d
            with ClasseDeclaration then TypeAtomique^ast := TypeAtomique^factory.createClasseType(d.getClasse());
            
            else error(MiniJava_badtype_classe, identificateur_type^txt);
        end
    else
        error(MiniJava_undefined_classe, identificateur_type^txt);
    end
end
}


SuiteTypeAtomique -> crochet_ouvrant crochet_fermant #calcul_prof SuiteTypeAtomique #remonte_prof ;
#calcul_prof {
do
    SuiteTypeAtomique1^calcul_profondeur := SuiteTypeAtomique^calcul_profondeur + 1;
end
}

#remonte_prof {
do
    SuiteTypeAtomique^profondeur_remontee := SuiteTypeAtomique1^profondeur_remontee;
end
}


SuiteTypeAtomique -> #remonte_prof ;
#remonte_prof {
do
    SuiteTypeAtomique^profondeur_remontee := SuiteTypeAtomique^calcul_profondeur;
end
}


Instructions -> ;

Instructions -> #inh Instruction #instr Instructions ;
#inh {
do
    Instruction^factory := new BlockFactoryImpl();
    
    Instruction^tds := Instructions^tds;
    Instructions1^tds := Instructions^tds;
end
}

#instr {
do
    Instructions^blocParent.add(Instruction^instr);
end
}


Instruction -> Type identificateur affectation #tds Expression point_virgule #instr ;
#tds {
do
    Expression^tds := Instruction^tds;
end
}

#instr {
local
	d : VariableDeclaration;
do
	if Instruction^tds.contains(identificateur^txt) then
		error(MiniJava_already_defined, identificateur^txt);
	else
		d := Instruction^factory.createVariableDeclaration(identificateur^txt, Type^ast, Expression^ast);
		
		Instruction^tds.register(d);
		Instruction^instr := d;
	end
end
}


Instruction -> #tds Affectable affectation Expression #instr point_virgule ;
#tds {
do
    Affectable^tds := Instruction^tds;
    Expression^tds := Instruction^tds;
end
}

#instr {
do
    Instruction^instr := Instruction^factory.createAssignment(Affectable^ast, Expression^ast);
end
}

Affectable -> parenthese_ouvrante #tds Affectable parenthese_fermante #ast ;

#tds {
do
    Affectable1^tds := Affectable^tds;
end
}

#ast {
do
    Affectable^ast := Affectable1^ast;
end
}

Affectable -> identificateur #tds #inh SuiteAffectable #ast ;
#tds {
do
    SuiteAffectable^tds := Affectable^tds;
end
}

#inh {
local
    o : Optional<Declaration>;
    d : Declaration;
do
    if (Affectable^tds.knows(identificateur^txt)) then
        o := Affectable^tds.get(identificateur^txt);
        d := o.get();
        match d
        with VariableDeclaration then SuiteAffectable^support := Affectable^factory.createVariableAssignment( d );
        with ConstantDeclaration then error(MiniJava_not_a_variable, identificateur^txt);
        end
    else
        error(MiniJava_undefined_ident, identificateur^txt);
    end
end
}

#ast {
do
    Affectable^ast := SuiteAffectable^ast;
end
}


SuiteAffectable -> #ast ;
#ast { 
do  
    SuiteAffectable^ast := SuiteAffectable^support;  
end  
}

--SuiteAffectable -> point identificateur #tds AppelOuAcces ;
--#tds {
--do
--    AppelOuAcces^tds := SuiteAffectable^tds;
--end
--}

--SuiteAffectable -> crochet_ouvrant #tds Expression crochet_fermant #inh SuiteAffectable #ast ;
--#tds {
--do
--    Expression^tds := SuiteAffectable^tds;
--    SuiteAffectable1^tds := SuiteAffectable^tds;
--end
--}

--#inh {
--do
--    SuiteAffectable1^support := SuiteAffectable^factory.createArrayAssignment(SuiteAffectable^support,Expression^ast);  
--end
--}

--#ast {
--do
--    SuiteAffectable^ast := SuiteAffectable1^ast;   
--end
--}


Instruction -> si parenthese_ouvrante #tds Expression parenthese_fermante Bloc SuiteConditionnelle #instr ;
#tds {
do
    Expression^tds := Instruction^tds;
    SuiteConditionnelle^tds := Instruction^tds;
    
    Bloc^tds := new SymbolTable(Instruction^tds);
end
}

#instr {
local
    sc_bloc : Block;
do
    sc_bloc := SuiteConditionnelle^suite_cond_bloc;
    
    if sc_bloc = null then
        Instruction^instr := Instruction^factory.createConditional(Expression^ast, Bloc^ast);
    else
        Instruction^instr := Instruction^factory.createConditional(Expression^ast, Bloc^ast, sc_bloc);
    end
end
}


SuiteConditionnelle -> #suite_cond_bloc ;
#suite_cond_bloc {
do
    SuiteConditionnelle^suite_cond_bloc := null;
end
}

SuiteConditionnelle -> sinon #tds Bloc #suite_cond_bloc ;
#tds {
do
    Bloc^tds := new SymbolTable(SuiteConditionnelle^tds);
end
}

#suite_cond_bloc {
do
    SuiteConditionnelle^suite_cond_bloc := Bloc^ast;
end
}

Instruction -> tant_que parenthese_ouvrante #tds Expression parenthese_fermante Bloc #instr ;
#tds {
do
    Expression^tds := Instruction^tds;
    Bloc^tds := new SymbolTable(Instruction^tds);
end
}

#instr {
do
    Instruction^instr := Instruction^factory.createRepetition(Expression^ast, Bloc^ast);
end
}


Instruction -> afficher Expression point_virgule #instr ;
#instr {
do
    Instruction^instr := Instruction^factory.createPrinter(Expression^ast);
end
}

--Instruction -> retour Expression point_virgule ;


Expression -> #tds Condition #inh SuiteCondition #ast ;
#tds {
do
    Condition^tds := Expression^tds;
    SuiteCondition^tds := Expression^tds;
end
}

#inh {
do
    SuiteCondition^gauche := Condition^ast;
end 
}

#ast {
do
    Expression^ast := SuiteCondition^ast;
end 
}


SuiteCondition -> #tds Comparatif Condition #ast ;
#tds {
do
    Condition^tds := SuiteCondition^tds;
end
}

#ast {
do
    SuiteCondition^ast :=
    SuiteCondition^factory.createBinaryExpression(
        SuiteCondition^gauche,
        Comparatif^bin_op,
        Condition^ast);
end 
}

SuiteCondition -> #ast ;
#ast {
do
    SuiteCondition^ast := SuiteCondition^gauche;
end 
}


Comparatif -> egalite #texte ;
#texte {
do
    Comparatif^bin_op := BinaryOperator.Equals;
end
}

Comparatif -> different #texte ;
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Different;   
end  
}

Comparatif -> inferieur #texte ;
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Lesser;   
end  
}

Comparatif -> inferieur_egal #texte ;
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.LesserOrEqual;   
end  
}

Comparatif -> superieur #texte ;
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.Greater;    
end  
}

Comparatif -> superieur_egal #texte ;
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.GreaterOrEqual;    
end  
}

   
Condition -> #tds Terme #ast_inh SuiteTerme #ast_syn ;
#tds {
do
    Terme^tds := Condition^tds;
    SuiteTerme^tds := Condition^tds;
end
}

#ast_inh {
do 
    SuiteTerme^gauche := Terme^ast; 
end 
}

#ast_syn {
do
    Condition^ast := SuiteTerme^ast; 
end
}


SuiteTerme -> Additif #tds Terme #ast_inh SuiteTerme #ast_syn ;
#tds {
do
    SuiteTerme1^tds := SuiteTerme^tds;
    Terme^tds := SuiteTerme^tds;
end
}

#ast_inh {
do
    SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
	  SuiteTerme^gauche,  
	  Additif^bin_op,  
	  Terme^ast);  
end 
}

#ast_syn {
do 
    SuiteTerme^ast := SuiteTerme1^ast; 
end 
}

SuiteTerme -> #ast ;
#ast {
do
    SuiteTerme^ast := SuiteTerme^gauche;
end
}

Additif -> addition #ast;  
#ast { 
do  
    Additif^bin_op := BinaryOperator.Add;  
end  
}

Additif -> soustraction #ast;  
#ast {  
do  
    Additif^bin_op := BinaryOperator.Substract;   
end  
}
   
Additif -> ou #ast;  
#ast {  
do
    Additif^bin_op := BinaryOperator.Or;   
end  
}
  
Terme -> #tds Facteur #ast_inh SuiteFacteur #ast_syn ;
#tds {
do
    Facteur^tds := Terme^tds;
    SuiteFacteur^tds := Terme^tds;
end
}
#ast_inh {
do 
    SuiteFacteur^gauche := Facteur^ast; 
end 
}

#ast_syn {
do
    Terme^ast := SuiteFacteur^ast; 
end
}

SuiteFacteur -> Multiplicatif #tds Facteur #ast_inh SuiteFacteur #ast_syn ;
#tds {
do
    Facteur^tds := SuiteFacteur^tds;
    SuiteFacteur1^tds := SuiteFacteur^tds;
end
}

#ast_inh {
do 
    SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
	  SuiteFacteur^gauche,  
	  Multiplicatif^bin_op,  
	  Facteur^ast);  
end 
}

#ast_syn {
do 
    SuiteFacteur^ast := SuiteFacteur1^ast; 
end 
}
 
SuiteFacteur -> #ast;  
#ast {
do
    SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

Multiplicatif -> multiplication #ast; 
#ast {
do 
    Multiplicatif^bin_op := BinaryOperator.Multiply; 
end 
}

Multiplicatif -> division #ast; 
#ast { 
do 
    Multiplicatif^bin_op := BinaryOperator.Divide;  
end 
}
 
Multiplicatif -> modulo #ast; 
#ast {  
do 
    Multiplicatif^bin_op := BinaryOperator.Modulo;   
end 
}
  
Multiplicatif -> et #ast; 
#ast {  
do 
    Multiplicatif^bin_op := BinaryOperator.And;   
end 
}

  
--Facteur -> accolade_ouvrante #tds Expressions accolade_fermante #ast ;
--#tds {
--do
--    Expressions^tds := Facteur^tds;
--end
--}

--#ast {
--do
--    Facteur^ast := Facteur^factory.createSequence( Expressions^expressions );
--end
--}


Expressions -> #tds Expression SuiteExpressions #ast ;
#tds {
do
    Expression^factory := new BlockFactoryImpl();
    Expression^tds := Expressions^tds;
    SuiteExpressions^tds := Expressions^tds;
end
}

#ast {
do 
    SuiteExpressions^expressions.addFirst(Expression^ast); 
    Expressions^expressions := SuiteExpressions^expressions; 
end 
}

SuiteExpressions -> virgule #tds Expression SuiteExpressions #ast ;
#tds {
do
    Expression^factory := new BlockFactoryImpl();
    Expression^tds := SuiteExpressions^tds;
    SuiteExpressions1^tds := SuiteExpressions^tds;
end
}

#ast {
do 
    SuiteExpressions1^expressions.addFirst(Expression^ast); 
    SuiteExpressions^expressions := SuiteExpressions1^expressions; 
end 
}

SuiteExpressions -> #ast ;
#ast {
do
    SuiteExpressions^expressions := new LinkedList<Expression>();
end
}


Facteur -> soustraction #tds Facteur #ast ;  
#tds {
do
    Facteur1^tds := Facteur^tds;
end
}

#ast { 
do  
    Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);  
end  
}  

Facteur -> negation #tds Facteur #ast ;  
#tds {
do
    Facteur1^tds := Facteur^tds;
end
}

#ast {
do
    Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);  
end
}

Facteur -> nouveau #tds Type #inh SuiteNouveau #ast ; 
#tds {
do
    Type^tds := Facteur^tds;
    SuiteNouveau^tds := Facteur^tds;
end
}

#inh {
do 
    SuiteNouveau^type := Type^ast; 
end
}

#ast {
do 
    Facteur^ast := SuiteNouveau^ast; 
end 
}


SuiteNouveau -> crochet_ouvrant #tds Expression crochet_fermant #ast ;
#tds {
do
    Expression^tds := SuiteNouveau^tds;
end
}

#ast {
do  
    --SuiteNouveau^ast := SuiteNouveau^factory.createArrayAllocation(SuiteNouveau^type,Expression^ast);
    SuiteNouveau^ast := null;
end  
}

SuiteNouveau -> #tds Arguments #ast ;
#tds {
do
    Arguments^tds := SuiteNouveau^tds;
end
}

#ast {
do 
    match SuiteNouveau^type
        with ClasseTypeImpl then
            SuiteNouveau^ast := SuiteNouveau^factory.createClasseInstanceAllocation(
                                SuiteNouveau^type.getClasse(),
                                Arguments^args);
        else
            error(MiniJava_badtype_classe, SuiteNouveau^type.toString());
    end
end 
}

Arguments -> parenthese_ouvrante parenthese_fermante #args ;
#args {
do
    Arguments^args := new LinkedList<Expression>();
end
}

Arguments -> parenthese_ouvrante #tds Expressions parenthese_fermante #args ;
#tds {
do
    Expressions^tds := Arguments^tds;
end
}

#args {
do
    Arguments^args := Expressions^expressions;
end
}


Facteur -> Valeur #ast;
#ast {
do
    Facteur^ast := Valeur^ast;
end
}

 
Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt); 
end
}

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);  
end
}

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);  
end
}

--Valeur -> chaine ;

--Valeur -> caractere ;


Facteur -> identificateur #tds #inh AppelOuAcces #ast;
#tds {
do
    AppelOuAcces^tds := Facteur^tds;
end
}

#inh {
local
   f : Optional<Declaration>;
   d : Declaration;
do
   if (Facteur^tds.knows(identificateur^txt)) then
      f := Facteur^tds.get(identificateur^txt);
      d := f.get();
      match d
      with ConstantDeclaration then AppelOuAcces^support := d.getValue();
      with VariableDeclaration then AppelOuAcces^support := Facteur^factory.createVariableUse(d);
      end
   else
      error(MiniJava_undefined_ident, identificateur^txt);
   end
end
}

#ast {
do
    Facteur^ast := AppelOuAcces^ast;
end
}


AppelOuAcces -> #tds Acces #ast ;
#tds {
do
    Acces^tds := AppelOuAcces^tds;
    Acces^support := AppelOuAcces^support;
end
}

#ast {
do
    AppelOuAcces^ast := Acces^ast;
end
}

--AppelOuAcces -> #tds Appel #ast ;
--#tds {
--do
--    Appel^tds := AppelOuAcces^tds;
--end
--}

--#ast {
--do
--    AppelOuAcces^ast := Appel^ast;
--end
--}


Acces -> #ast ;
#ast {
do  
    Acces^ast := Acces^support;  
end  
}

Acces -> crochet_ouvrant #tds Expression crochet_fermant #inh Acces #ast;
#tds {
do
    Acces1^tds := Acces^tds;
    Expression^tds := Acces^tds;
end
}

#inh {
do
    Acces1^support := Acces^factory.createArrayAccess(Acces^support,Expression^ast);
end
}

#ast { 
do  
    Acces^ast := Acces1^ast;  
end
}


--Acces -> point identificateur #tds AppelOuAcces #ast ;
--#tds {
--do
--    AppelOuAcces^tds := Acces^tds;
--end
--}

--#ast {
--do
--    Acces^ast := AppelOuAcces^ast;
--end
--}

--Appel -> parenthese_ouvrante parenthese_fermante #tds #inh Acces #ast ;
--#tds {
--do
--    Acces^tds := Appel^tds;
--end
--}

--#ast {
--do
--    Appel^ast := Acces^ast;
--end
--}
 
--Appel -> parenthese_ouvrante Expressions parenthese_fermante #tds Acces #ast ;
--#tds {
--do
--    Acces^tds := Appel^tds;
--end
--}

--#ast {
--do
--    Appel^ast := Acces^ast;
--end
--}

end
