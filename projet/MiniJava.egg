----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;

inh gauche	: Expression for SuiteCondition, SuiteTerme, SuiteFacteur;
inh factory	: BlockFactory for Bloc, Instruction,
                    SuiteConditionnelle, Instructions, Expression, Condition,
                    SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur,
                    Type, TypeAtomique, Valeur, Affectable, SuiteAffectable,
                    AppelOuAcces, Acces, Appel, SuiteNouveau;

inh tds : SymbolTable for Bloc, Instructions, Instruction, Expression, SuiteConditionnelle,
                    Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Type,
                    TypeAtomique, Affectable, SuiteAffectable, Expressions, SuiteExpressions,
                    AppelOuAcces, Acces, Appel, SuiteNouveau, Parametres, Parametre, SuiteParametres,
                    Principale, MethodePrincipale, Interfaces, Interface, ElementsInterface,
                    ElementInterface, Signature, Classes, Classe, ElementsClasse, ElementClasse,
                    Constructeur, AttributOuMethode, SuiteAttributOuMethode, Arguments, HeritageInterface,
                    SuiteHeritageInterface, ImplantationInterface;

inh blocParent	: Block for Instructions;

inh support : Assignable for SuiteAffectable;
syn ast 	: Assignable for SuiteAffectable, Affectable;

inh support : Expression for AppelOuAcces, Acces, Appel;
syn ast		: Expression for AppelOuAcces, Acces, Appel;

syn expressions : LinkedList<Expression> for Expressions, SuiteExpressions;

inh type : Type for SuiteNouveau;

--GESTION DES TYPES

inh calcul_profondeur : Integer for SuiteTypeAtomique;
syn profondeur_remontee : Integer for SuiteTypeAtomique;

syn ast : Type for Type, TypeAtomique;


--PROGRAMME ASTS

syn ast     : Program for Programme;

--Principale
syn ast     : ClassePrincipale for Principale;
syn bloc    : Block for MethodePrincipale;

--Interfaces
syn ast        : Interface for Interface;
syn interfaces : LinkedList<Interface> for Interfaces, ImplantationInterface, HeritageInterface, SuiteHeritageInterface;
syn unknownInterfaces : LinkedList<String> for HeritageInterface, SuiteHeritageInterface;
inh interface_mere : Interface for ElementsInterface, ElementInterface;

--Signatures d'interfaces
syn type : Optional<Type> for Signature;
syn nom : String for Signature;
syn args : LinkedList<Argument> for Signature;

--Classes
syn ast     : Classe for Classe;
syn classes : LinkedList<Classe> for Classes;
inh classe_mere : Classe for ElementsClasse, ElementClasse;

--Héritage
syn superClasse		: String for HeritageClasse;


--Methodes et arguments de classe
syn type            : Optional<Type> for AttributOuMethode;
syn nom             : String for AttributOuMethode;
syn methode_corps   : Block for AttributOuMethode, SuiteAttributOuMethode;
syn methode_arguments : LinkedList<Argument> for AttributOuMethode, SuiteAttributOuMethode;

syn args            : LinkedList<Argument> for Parametres, SuiteParametres;
syn nom             : String for Parametre;
syn type            : Type for Parametre;

inh droit : DroitAcces for ElementClasse;
syn droit : DroitAcces for DroitAcces;

--Constructeur de classe
syn args : LinkedList<Argument> for Constructeur;
syn bloc : Block for Constructeur;
syn args : LinkedList<Expression> for Arguments;

--

syn ast		: Block for Bloc;
syn ast		: Expression for Expression, Condition, SuiteCondition,
    Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau;

syn instr	: Instruction for Instruction;

syn bin_op	: BinaryOperator for Additif, Multiplicatif, Comparatif;

syn suite_cond_bloc : Block for SuiteConditionnelle;

space  separateur				is    "[\n\r\t ]+";
space  commentaire				is    "\/\/.*\n";
sugar  accolade_ouvrante		is    "\{";  
sugar  accolade_fermante		is    "\}";  
sugar  crochet_ouvrant			is    "\[";  
sugar  crochet_fermant			is    "\]";  
sugar  parenthese_ouvrante		is    "\(";
sugar  parenthese_fermante		is    "\)";
sugar  inferieur				is    "\<";  
sugar  superieur				is    "\>";  
sugar  inferieur_egal			is    "\<=";  
sugar  superieur_egal			is    "\>=";  
sugar  point					is    "\.";  
sugar  point_virgule			is    ";";  
sugar  virgule					is    ",";
sugar  affectation				is    "=";
sugar  egalite					is    "==";  
sugar  different				is    "\!=";  
sugar  addition					is    "\+";
sugar  soustraction				is    "\-";
sugar  ou						is    "\|\|";  
sugar  multiplication			is    "\*";
sugar  division					is    "/";
sugar  modulo					is    "%";
sugar  adresse					is    "&";  
sugar  negation					is    "\!";  
sugar  et						is    "&&";  
sugar  vrai						is    "true";
sugar  faux						is    "false";
sugar  si						is    "if";
sugar  sinon					is    "else";
sugar  afficher					is    "print";  
sugar  nouveau					is    "new";  
sugar  tant_que					is    "while";  
sugar  retour					is    "return";  
sugar  type_int					is    "int";
sugar  type_bool				is    "boolean";  
sugar  type_float				is    "float";  
sugar  type_char				is    "char";        
sugar  type_String				is    "String";        
sugar vide						is    "void";     
sugar null						is    "null";     
sugar  choix					is    "\?";         
sugar  deux_points				is    ":";          
sugar  interface				is    "interface";     
sugar  classe					is    "class";      
sugar  extension				is    "extends";      
sugar  implantation				is    "implements";      
sugar public					is    "public";    
sugar protege					is    "protected";    
sugar prive						is    "private";     
sugar statique					is    "static";       
sugar final						is    "final";       
sugar principale				is    "main";  
term   chaine					is    "\"([^\"]|\\\")*\"";  
term   caractere				is    "\'[^\']\'";  
term   entier					is    "[0-9]+";
term   identificateur			is    "[a-z_][a-zA-Z0-9_]*"; 
term   identificateur_type		is    "[A-Z][a-zA-Z0-9_]*"; 


Programme -> #tds Interfaces Classes Principale #ast ;
#tds {
local
    tds : SymbolTable;
do
    tds := new SymbolTable();
    
    Interfaces^tds := tds;
    Classes^tds := tds;
    Principale^tds := tds;
end
}

#ast {
local
    prg : ProgramFactoryImpl;
do
    prg := new ProgramFactoryImpl();
    
    Collections.reverse(Interfaces^interfaces);
    Collections.reverse(Classes^classes);
    Programme^ast := prg.createProgram(Principale^ast, Interfaces^interfaces, Classes^classes);
end
}


Interfaces -> #tds Interface #tds1 Interfaces #interfaces ;
#tds {
do
    Interface^tds := Interfaces^tds;
end
}

#tds1 {
local
    fac : BlockFactoryImpl;
do
    fac := new BlockFactoryImpl();
    
    if Interfaces^tds.contains(Interface^ast.getNom()) then
        error(MiniJava_interface_already_defined, Interface^ast.getNom());
        Interfaces1^tds := Interfaces^tds;
	else
        Interfaces1^tds := Interfaces^tds;
        Interfaces1^tds.register( fac.createInterfaceDeclaration(Interface^ast) );
    end
end
}

#interfaces {
do
    Interfaces^interfaces := Interfaces1^interfaces;
    Interfaces^interfaces.add(Interface^ast);
end
}

Interfaces -> #interfaces ;
#interfaces {
do
    Interfaces^interfaces := new LinkedList<Interface>();
end
}

Interface -> interface identificateur_type Genericite #inh HeritageInterface accolade_ouvrante #ast_inh ElementsInterface accolade_fermante ;
#ast_inh {
local
    prg : ProgramFactoryImpl;
    interface : Interface;
do
    --AST
    prg := new ProgramFactoryImpl();
    interface := prg.createInterface(identificateur_type^txt, HeritageInterface^interfaces, HeritageInterface^unknownInterfaces);
    
    Interface^ast := interface;
    
    --INH
    ElementsInterface^tds := Interface^tds;
    ElementsInterface^interface_mere := interface;
end
}

#inh {
do
	HeritageInterface^tds := Interface^tds;
end
}

HeritageInterface -> extension identificateur_type InstanceGenericite #inh SuiteHeritageInterface #syn;
#syn {
local
	f : Optional<Declaration>;
    d : Declaration;
do
	HeritageInterface^interfaces := SuiteHeritageInterface^interfaces;
	HeritageInterface^unknownInterfaces := SuiteHeritageInterface^unknownInterfaces;
	
	if (HeritageInterface^tds.knows(identificateur_type^txt)) then
		f := HeritageInterface^tds.get(identificateur_type^txt);
		d := f.get();
		match d
			with InterfaceDeclarationImpl then HeritageInterface^interfaces.add(d.getInterface());
		else
			error(MiniJava_Heritage_NonExist, identificateur_type^txt);
		end
	else
		HeritageInterface^unknownInterfaces.add(identificateur_type^txt);
	end
end
}

#inh {
do
	SuiteHeritageInterface^tds := HeritageInterface^tds;
end
}

HeritageInterface -> #syn;
#syn {
do
	HeritageInterface^interfaces := new LinkedList<Interface>();
	HeritageInterface^unknownInterfaces := new LinkedList<String>();
end
}


SuiteHeritageInterface -> virgule identificateur_type InstanceGenericite #inh SuiteHeritageInterface #syn ;
#inh {
do
	SuiteHeritageInterface1^tds := SuiteHeritageInterface^tds;	
end
}

#syn {
local
	f : Optional<Declaration>;
    d : Declaration;
do
	SuiteHeritageInterface^interfaces := SuiteHeritageInterface1^interfaces;
	SuiteHeritageInterface^unknownInterfaces := SuiteHeritageInterface1^unknownInterfaces;
	if (SuiteHeritageInterface^tds.knows(identificateur_type^txt)) then
		f := SuiteHeritageInterface^tds.get(identificateur_type^txt);
		d := f.get();
		match d
			with InterfaceDeclarationImpl then SuiteHeritageInterface^interfaces.add(d.getInterface());
		else
			error(MiniJava_Heritage_NonExist, identificateur_type^txt);
		end
	else
		SuiteHeritageInterface^unknownInterfaces.add(identificateur_type^txt);
	end
end
}


SuiteHeritageInterface -> #syn;
#syn {
do
	SuiteHeritageInterface^interfaces := new LinkedList<Interface>();
	SuiteHeritageInterface^unknownInterfaces := new LinkedList<String>();
end
}


ElementsInterface -> #tds #inh ElementInterface ElementsInterface ;
#tds {
do
    ElementInterface^tds := ElementsInterface^tds;
    ElementsInterface1^tds := ElementsInterface^tds;
end
}

#inh {
do
    ElementInterface^interface_mere := ElementsInterface^interface_mere;
    ElementsInterface1^interface_mere := ElementsInterface^interface_mere;
end
}

ElementsInterface -> ;


ElementInterface -> final statique #tds #inh Type identificateur affectation Expression #ast point_virgule ;
#tds {
do
    Type^tds := ElementInterface^tds;
    Expression^tds := ElementInterface^tds;
end
}

#inh {
local
    fac : BlockFactoryImpl;
do
    fac := new BlockFactoryImpl();
    
    Type^factory := fac;
    Expression^factory := fac;
end
}

#ast {
do
	ElementInterface^interface_mere.ajouterConstante(Type^ast, identificateur^txt, Expression^ast);
end
}

ElementInterface -> #tds Signature point_virgule #ast ;
#tds {
do
    Signature^tds := ElementInterface^tds;
end
}

#ast {
do
    if (! ElementInterface^interface_mere.ajouterSignature(Signature^type,
                                                        Signature^nom,
                                                        Signature^args)
    ) then
        error(MiniJava_Signature_DejaDef, ElementInterface^interface_mere.getNom(), Signature^nom);
    end
end
}


Signature -> vide identificateur parenthese_ouvrante #tds Parametres parenthese_fermante #ast ;
#tds {
do
    Parametres^tds := Signature^tds;
end
}

#ast {
do
    Signature^type := Optional.empty();
    Signature^nom := identificateur^txt;
    Signature^args := Parametres^args;
end
}
 
Signature -> #tds #inh Type identificateur parenthese_ouvrante Parametres parenthese_fermante #ast ;
#tds {
do
    Type^tds := Signature^tds;
    Parametres^tds := Signature^tds;
end
}

#inh {
do
    Type^factory := new BlockFactoryImpl();
end
}

#ast {
do
    Signature^type := Optional.of(Type^ast);
    Signature^nom := identificateur^txt;
    Signature^args := Parametres^args;
end
}


Classes -> #tds Classe #tds1 Classes #classes ;
#tds {
do
    Classe^tds := Classes^tds;
end
}

#tds1 {
local
    fac : BlockFactoryImpl;
do
    fac := new BlockFactoryImpl();
    
    if Classes^tds.contains(Classe^ast.getNom()) then
        error(MiniJava_classe_already_defined, Classe^ast.getNom());
        Classes1^tds := Classes^tds;
	else
        Classes1^tds := Classes^tds;
        Classes1^tds.register( fac.createClasseDeclaration(Classe^ast) );
    end
end
}

#classes {
do
    Classes^classes := Classes1^classes;
    Classes^classes.add(Classe^ast);
end
}

Classes -> #classes ;
#classes {
do
    Classes^classes := new LinkedList<Classe>();
end
}


Classe -> classe  identificateur_type Genericite HeritageClasse #inh ImplantationInterface accolade_ouvrante #ast_inh ElementsClasse accolade_fermante ;
#ast_inh {
local
    prg : ProgramFactoryImpl;
    classe : Classe;
    superClasse : Classe;
    unknownClasse : String;
    f : Optional<Declaration>;
    d : Declaration;
do
    --AST
    prg := new ProgramFactoryImpl();
    if (HeritageClasse^superClasse = null) then					-- S'il n'y a pas d'héritage.
		if (ImplantationInterface^interfaces.size() != 0) then		-- S'il y a implantation d'interfaces.
			Collections.reverse(ImplantationInterface^interfaces);
			classe := prg.createClasseImplementant(identificateur_type^txt, ImplantationInterface^interfaces);
		else
			classe := prg.createClasse(identificateur_type^txt);	-- S'il n'y a pas implantation.
		end
	else														-- S'il y a héritage.
		if (Classe^tds.knows(HeritageClasse^superClasse)) then
			f := Classe^tds.get(HeritageClasse^superClasse);
			d := f.get();
			match d 
				with ClasseDeclarationImpl then superClasse := d.getClasse();
				if (ImplantationInterface^interfaces.size() = 0) then		-- Pas d'implantation
					classe := prg.createClasseHeritant(identificateur_type^txt, superClasse, null);
				else
					Collections.reverse(ImplantationInterface^interfaces);	-- Implantation d'interfaces
					classe := prg.createClasseHeritant(identificateur_type^txt, superClasse, ImplantationInterface^interfaces, null);
				end
			else 
				error(MiniJava_Heritage_NonExist, HeritageClasse^superClasse);
				if (ImplantationInterface^interfaces.size() != 0) then		-- S'il y a implantation d'interfaces.
					Collections.reverse(ImplantationInterface^interfaces);
					classe := prg.createClasseImplementant(identificateur_type^txt, ImplantationInterface^interfaces);
				else
					classe := prg.createClasse(identificateur_type^txt);	-- S'il n'y a pas implantation.
				end
			end
			
		else
			superClasse := null;
			unknownClasse := HeritageClasse^superClasse;
			if (ImplantationInterface^interfaces.size() = 0) then		-- Pas d'implantation
			    classe := prg.createClasseHeritant(identificateur_type^txt, superClasse, unknownClasse);
			else
				Collections.reverse(ImplantationInterface^interfaces);
				classe := prg.createClasseHeritant(identificateur_type^txt, superClasse, ImplantationInterface^interfaces, unknownClasse);
			end
		end    
    
    end
    Classe^ast := classe;
    
    --INH
    ElementsClasse^tds := Classe^tds;
    ElementsClasse^classe_mere := classe;
end
}

#inh {
do
	ImplantationInterface^tds := Classe^tds;
end
}

HeritageClasse -> extension identificateur_type #syn InstanceGenericite ;
#syn {
do
	HeritageClasse^superClasse := identificateur_type^txt;
end
}


HeritageClasse -> #syn;
#syn {
do
	HeritageClasse^superClasse := null;
end
}

ImplantationInterface -> implantation identificateur_type InstanceGenericite #inh SuiteHeritageInterface #syn;
#syn {
local
	f : Optional<Declaration>;
    d : Declaration;
do
	ImplantationInterface^interfaces := SuiteHeritageInterface^interfaces;
	
	if (ImplantationInterface^tds.knows(identificateur_type^txt)) then
		f := ImplantationInterface^tds.get(identificateur_type^txt);
		d := f.get();
		match d
			with InterfaceDeclarationImpl then ImplantationInterface^interfaces.add(d.getInterface());
		else
			error(MiniJava_Heritage_NonExist, identificateur_type^txt);
		end
	else
		error(MiniJava_Heritage_NonExist, identificateur_type^txt);
	end
end
}

#inh {
do 
	SuiteHeritageInterface^tds := ImplantationInterface^tds;
end
}

ImplantationInterface -> #syn;
#syn {
do
	ImplantationInterface^interfaces := new LinkedList<Interface>();
end 
}




Principale -> public classe identificateur_type accolade_ouvrante #tds MethodePrincipale accolade_fermante #ast ;
#tds {
do
    MethodePrincipale^tds := Principale^tds;
end
}

#ast {
local
    prg : ProgramFactoryImpl;
do
    prg := new ProgramFactoryImpl();
    Principale^ast := prg.createPrincipale(identificateur_type^txt, MethodePrincipale^bloc);
end
}


MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante #tds Bloc #ast ;
#tds {
do
    Bloc^tds := new SymbolTable(MethodePrincipale^tds);
    Bloc^factory := new BlockFactoryImpl();
end
}

#ast {
do
    MethodePrincipale^bloc := Bloc^ast;
end
}


Genericite -> inferieur ParametresGenericite superieur ;

Genericite -> ;


ParametresGenericite -> ParametreGenericite SuiteParametresGenericite ;


SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite ;

SuiteParametresGenericite -> ;


ParametreGenericite -> identificateur_type HeritageGenericite ;  
 
ParametreGenericite -> choix HeritageGenericite ;  
 

HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite ;

HeritageGenericite -> ;

SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite ;

SuiteHeritageGenericite -> ;


InstanceGenericite -> ;

InstanceGenericite -> inferieur ArgumentsGenericite superieur ;


ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite ;


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite ;

SuiteArgumentsGenericite -> ;


ArgumentGenericite -> identificateur_type InstanceGenericite ;

ArgumentGenericite -> type_String ;


ElementsClasse -> DroitAcces #tds #inh ElementClasse ElementsClasse ;
#tds {
do
    ElementClasse^tds := ElementsClasse^tds;
    ElementsClasse1^tds := ElementsClasse^tds;
end
}

#inh {
do
    ElementClasse^classe_mere := ElementsClasse^classe_mere;
    ElementClasse^droit := DroitAcces^droit;
    
    ElementsClasse1^classe_mere := ElementsClasse^classe_mere;
end
}
  
ElementsClasse -> ;  
 

DroitAcces -> public #droit ;
#droit {
do
    DroitAcces^droit := DroitAcces.PUBLIC;
end
}
 
DroitAcces -> protege #droit ;
#droit {
do
    DroitAcces^droit := DroitAcces.PROTECTED;
end
}

DroitAcces -> prive #droit ;
#droit {
do
    DroitAcces^droit := DroitAcces.PRIVATE;
end
}
 

ElementClasse -> statique #tds AttributOuMethode #ast ;
#tds {
do
    AttributOuMethode^tds := ElementClasse^tds;
end
}

#ast {
local
    prg : ProgramFactoryImpl;
do
    prg := new ProgramFactoryImpl();
    
    if AttributOuMethode^methode_corps != null then     --UNE METHODE
        
        if (! ElementClasse^classe_mere.ajouterMethode(
            prg.createMethode(ElementClasse^classe_mere,
								AttributOuMethode^nom,
                                AttributOuMethode^methode_arguments,
                                AttributOuMethode^methode_corps,
                                ElementClasse^droit,
                                true,
                                AttributOuMethode^type) )
        ) then
            error(MiniJava_Methode_DejaDef, ElementClasse^classe_mere.getNom(), AttributOuMethode^nom);
        end
    
    else                                                --UN ATTRIBUT
        
        if (! ElementClasse^classe_mere.ajouterAttribut(
            prg.createAttribut(ElementClasse^classe_mere,
								AttributOuMethode^type.get(),
                                AttributOuMethode^nom,
                                ElementClasse^droit,
                                true) )
        ) then
            error(MiniJava_Attribut_DejaDef, ElementClasse^classe_mere.getNom(), AttributOuMethode^nom);
        end
    
    end
end
}
 
ElementClasse -> #tds AttributOuMethode #ast ;
#tds {
do
    AttributOuMethode^tds := ElementClasse^tds;
end
}

#ast {
local
    prg : ProgramFactoryImpl;
do
    prg := new ProgramFactoryImpl();
    
    if AttributOuMethode^methode_corps != null then     --UNE METHODE
        
        if (! ElementClasse^classe_mere.ajouterMethode(
            prg.createMethode(ElementClasse^classe_mere,
								AttributOuMethode^nom,
                                AttributOuMethode^methode_arguments,
                                AttributOuMethode^methode_corps,
                                ElementClasse^droit,
                                false,
                                AttributOuMethode^type) )
        ) then
            error(MiniJava_Methode_DejaDef, ElementClasse^classe_mere.getNom(), AttributOuMethode^nom);
        end
    
    else                                                --UN ATTRIBUT
        
        if (! ElementClasse^classe_mere.ajouterAttribut(
            prg.createAttribut(ElementClasse^classe_mere,
								AttributOuMethode^type.get(),
                                AttributOuMethode^nom,
                                ElementClasse^droit,
                                false) )
        ) then
            error(MiniJava_Attribut_DejaDef, ElementClasse^classe_mere.getNom(), AttributOuMethode^nom);
        end
    
    end
end
}
 
ElementClasse -> #tds Constructeur #ast ;
#tds {
do
    Constructeur^tds := ElementClasse^tds;
end
}

#ast {
local
    prg : ProgramFactoryImpl;
do
    prg := new ProgramFactoryImpl();
    
    if (! ElementClasse^classe_mere.ajouterConstructeur(
        prg.createConstructeur(ElementClasse^classe_mere,
                                ElementClasse^droit,
                                Constructeur^args,
                                Constructeur^bloc) )
    ) then
        error(MiniJava_Constructeur_DejaDef, ElementClasse^classe_mere.getNom());
    end
end
}

AttributOuMethode -> #tds #inh Type identificateur SuiteAttributOuMethode #ast ;
#tds {
do
    Type^tds := AttributOuMethode^tds;
end
}

#inh {
do
    Type^factory := new BlockFactoryImpl();
end
}

#ast {
do
    AttributOuMethode^type := Optional.of(Type^ast);
    AttributOuMethode^nom := identificateur^txt;
    AttributOuMethode^methode_corps := SuiteAttributOuMethode^methode_corps; --null si c'est un attribut
    AttributOuMethode^methode_arguments := SuiteAttributOuMethode^methode_arguments; --null si c'est un attribut
end
}

AttributOuMethode -> vide identificateur parenthese_ouvrante #tds Parametres parenthese_fermante #inh Bloc #ast ;
#tds {
do
    Parametres^tds := AttributOuMethode^tds;
    Bloc^tds := new SymbolTable(AttributOuMethode^tds);
end
}

#inh {
do
    Bloc^factory := new BlockFactoryImpl();
end
}

#ast {
do
    AttributOuMethode^type := Optional.empty();
    AttributOuMethode^nom := identificateur^txt;
    AttributOuMethode^methode_corps := Bloc^ast;
    AttributOuMethode^methode_arguments := Parametres^args;
end
}


SuiteAttributOuMethode -> point_virgule #ast ;
#ast {
do
    SuiteAttributOuMethode^methode_corps := null;     --C'est un attribut.
    SuiteAttributOuMethode^methode_arguments := null; --C'est un attribut.
end
}

SuiteAttributOuMethode -> parenthese_ouvrante #tds Parametres parenthese_fermante #inh Bloc #ast ;
#tds {
do
    Parametres^tds := SuiteAttributOuMethode^tds;
    Bloc^tds := new SymbolTable(SuiteAttributOuMethode^tds);
end
}

#inh {
do
    Bloc^factory := new BlockFactoryImpl();
end
}

#ast {
do
    SuiteAttributOuMethode^methode_corps := Bloc^ast;
    SuiteAttributOuMethode^methode_arguments := Parametres^args;
end
}


Constructeur -> identificateur_type parenthese_ouvrante #tds Parametres parenthese_fermante #inh Bloc #ast ;
#tds {
do
    Parametres^tds := Constructeur^tds;
    Bloc^tds := new SymbolTable(Constructeur^tds);
end
}

#inh {
do
    Bloc^factory := new BlockFactoryImpl();
end
}

#ast {
do
    Constructeur^args := Parametres^args;
    Constructeur^bloc := Bloc^ast;
end
}


Parametres -> #args ;
#args {
do
    Parametres^args := new LinkedList<Argument>();
end
}

Parametres -> #tds Parametre SuiteParametres #args ;
#tds {
do
    Parametre^tds := Parametres^tds;
    SuiteParametres^tds := Parametres^tds;
end
}

#args {
local
    prg : ProgramFactoryImpl;
    liste_args : LinkedList<Argument>;
do
    prg := new ProgramFactoryImpl();
    
    liste_args := new LinkedList<Argument>();
    liste_args.add( prg.createArgument(Parametre^type, Parametre^nom) );
    liste_args.addAll( SuiteParametres^args );
    
    Parametres^args := liste_args;
    
    --TESTER ICI SI IL N'Y A PAS DE DOUBLONS
end
}

Parametre -> #tds Type identificateur #ast ;
#tds {
do
    Type^tds := Parametre^tds;
    Type^factory := new BlockFactoryImpl();
end
}

#ast {
do
    Parametre^nom := identificateur^txt;
    Parametre^type := Type^ast;
end
}


SuiteParametres -> #args ;
#args {
do
    SuiteParametres^args := new LinkedList<Argument>();
end
}

SuiteParametres -> virgule #tds Parametre SuiteParametres #args ;
#tds {
do
    Parametre^tds := SuiteParametres^tds;
    SuiteParametres1^tds := SuiteParametres^tds;
end
}

#args {
local
    prg : ProgramFactoryImpl;
    liste_args : LinkedList<Argument>;
do
    prg := new ProgramFactoryImpl();
    
    liste_args := new LinkedList<Argument>();
    liste_args.add( prg.createArgument(Parametre^type, Parametre^nom) );
    liste_args.addAll( SuiteParametres1^args );
    
    SuiteParametres^args := liste_args;
end
}


Bloc -> accolade_ouvrante #ast Instructions accolade_fermante  ;
#ast {
local
    b : Block;
do
    b := Bloc^factory.createBlock();
    Bloc^ast := b;
    
    Instructions^blocParent := b;
    Instructions^tds := new SymbolTable(Bloc^tds);
end
}


Type -> #tds TypeAtomique #calcul_prof SuiteTypeAtomique #ast ;
#tds {
do
    TypeAtomique^tds := Type^tds;
end
}

#calcul_prof {
do
    SuiteTypeAtomique^calcul_profondeur := 0;
end
}

#ast {
do
    --Type^ast := Type^factory.makeTableType(TypeAtomique^ast,
    --                            SuiteTypeAtomique^profondeur_remontee); --A CODER !!!
    
    Type^ast := TypeAtomique^ast;
end
}


TypeAtomique -> type_bool #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createBooleanType();
end
}

TypeAtomique -> type_int #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createIntegerType();
end
} 
 
TypeAtomique -> type_char #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createCharType(); --A CODER ?
end
}
 
--TypeAtomique -> type_float #ast ;
--#ast {
--do
--    TypeAtomique^ast :=  TypeAtomique^factory.createFloatingType(); --A CODER ?
--end
--}

TypeAtomique -> type_String #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createStringType(); --A CODER ?
end
}
 
TypeAtomique -> identificateur_type InstanceGenericite #ast ;
#ast {
local
    f : Optional<Declaration>;
    d : Declaration;
do
    if (TypeAtomique^tds.knows(identificateur_type^txt)) then
        f := TypeAtomique^tds.get(identificateur_type^txt);
        d := f.get();
        match d
            with ClasseDeclaration then TypeAtomique^ast := TypeAtomique^factory.createClasseType(d.getClasse());
            with InterfaceDeclaration then TypeAtomique^ast := TypeAtomique^factory.createInterfaceType(d.getInterface());
            
            else error(MiniJava_badtype_classe, identificateur_type^txt);
        end
    else
        TypeAtomique^ast := TypeAtomique^factory.createUndeclaredType(identificateur_type^txt);
    end
end
}


SuiteTypeAtomique -> crochet_ouvrant crochet_fermant #calcul_prof SuiteTypeAtomique #remonte_prof ;
#calcul_prof {
do
    SuiteTypeAtomique1^calcul_profondeur := SuiteTypeAtomique^calcul_profondeur + 1;
end
}

#remonte_prof {
do
    SuiteTypeAtomique^profondeur_remontee := SuiteTypeAtomique1^profondeur_remontee;
end
}


SuiteTypeAtomique -> #remonte_prof ;
#remonte_prof {
do
    SuiteTypeAtomique^profondeur_remontee := SuiteTypeAtomique^calcul_profondeur;
end
}


Instructions -> ;

Instructions -> #inh Instruction #instr Instructions ;
#inh {
do
    Instruction^factory := new BlockFactoryImpl();
    
    Instruction^tds := Instructions^tds;
    Instructions1^tds := Instructions^tds;
end
}

#instr {
do
    Instructions^blocParent.add(Instruction^instr);
end
}


Instruction -> Type identificateur affectation #tds Expression point_virgule #instr ;
#tds {
do
    Expression^tds := Instruction^tds;
end
}

#instr {
local
	d : VariableDeclaration;
do
	if Instruction^tds.contains(identificateur^txt) then
		error(MiniJava_already_defined, identificateur^txt);
	else
        match Type^ast
            with ClasseTypeImpl then
                d := Instruction^factory.createClasseInstanceDeclaration(identificateur^txt, Type^ast, Expression^ast);
            
            with UndeclaredTypeImpl then
                d := Instruction^factory.createUndeclaredInstanceDeclaration(identificateur^txt, Type^ast.getNom(), Expression^ast);
            
            with InterfaceTypeImpl then
                d := Instruction^factory.createInterfaceInstanceDeclaration(identificateur^txt, Type^ast, Expression^ast);
            
            else d := Instruction^factory.createVariableDeclaration(identificateur^txt, Type^ast, Expression^ast);
        end
		
		Instruction^tds.register(d);
		Instruction^instr := d;
	end
end
}


Instruction -> #tds Affectable affectation Expression #instr point_virgule ;
#tds {
do
    Affectable^tds := Instruction^tds;
    Expression^tds := Instruction^tds;
end
}

#instr {
do
    Instruction^instr := Instruction^factory.createAssignment(Affectable^ast, Expression^ast);
end
}

Affectable -> parenthese_ouvrante #tds Affectable parenthese_fermante #ast ;

#tds {
do
    Affectable1^tds := Affectable^tds;
end
}

#ast {
do
    Affectable^ast := Affectable1^ast;
end
}

Affectable -> identificateur #tds #inh SuiteAffectable #ast ;
#tds {
do
    SuiteAffectable^tds := Affectable^tds;
end
}

#inh {
local
    o : Optional<Declaration>;
    d : Declaration;
do
    if (Affectable^tds.knows(identificateur^txt)) then
        o := Affectable^tds.get(identificateur^txt);
        d := o.get();
        match d
            with ClasseInstanceDeclaration then SuiteAffectable^support := Affectable^factory.createInstanceAssignment_dec( d );
            with UndeclaredInstanceDeclaration then SuiteAffectable^support := Affectable^factory.createUndeclaredAccessAssignment_dec( d );
            with VariableDeclaration then SuiteAffectable^support := Affectable^factory.createVariableAssignment( d );
            with ConstantDeclaration then error(MiniJava_not_a_variable, identificateur^txt);
        end
    else
        --On le définit comme une tentative (dans un premier temps) d'accès à un membre de classe.
        if (identificateur^txt.equals("this")) then
            SuiteAffectable^support := Affectable^factory.createMembreClasseAccessAssignment_identifier(Identifier.THIS, "");
        else
            if (identificateur^txt.equals("super")) then
                SuiteAffectable^support := Affectable^factory.createMembreClasseAccessAssignment_identifier(Identifier.SUPER, "");
            else
                SuiteAffectable^support := Affectable^factory.createMembreClasseAccessAssignment_identifier(Identifier.UNKNOWN, identificateur^txt);
            end
        end
    end
end
}

#ast {
do
    Affectable^ast := SuiteAffectable^ast;
end
}


SuiteAffectable -> #ast ;
#ast { 
do  
    SuiteAffectable^ast := SuiteAffectable^support;  
end  
}

SuiteAffectable -> point identificateur #tds #inh AppelOuAcces #ast ;
#tds {
do
    AppelOuAcces^tds := SuiteAffectable^tds;
end
}

#inh {
local
    supp : Assignable;
do
    supp := SuiteAffectable^support;
    match supp
        with InstanceAssignmentImpl then
            AppelOuAcces^support := SuiteAffectable^factory.createInstanceAccess_use(supp.getInstanceUse(), identificateur^txt);

        
        with MembreClasseAccessAssignmentImpl then
            AppelOuAcces^support := SuiteAffectable^factory.createMembreClasseAccessAssignment_accesstxt( supp, identificateur^txt );
        
        with UndeclaredAccessAssignmentImpl then
            supp.setNomAcces(identificateur^txt);
            AppelOuAcces^support := supp;
       
        else error(MiniJava_Acces_NonImplemente);
    end
end
}

#ast {
local
    obtained_ast : Expression;
do
    obtained_ast := AppelOuAcces^ast;
    match obtained_ast
        with InstanceAccessImpl then
            SuiteAffectable^ast := SuiteAffectable^factory.createInstanceAssignment_rec( obtained_ast );
        
        with MembreClasseAccessImpl then
            SuiteAffectable^ast := SuiteAffectable^factory.createMembreClasseAccessAssignment_access( obtained_ast );
        
        with UndeclaredAccessImpl then
            SuiteAffectable^ast := SuiteAffectable^factory.createUndeclaredAccessAssignment_access( obtained_ast );
    
        else error(MiniJava_Acces_NonImplemente);
    end
end
}

--SuiteAffectable -> crochet_ouvrant #tds Expression crochet_fermant #inh SuiteAffectable #ast ;
--#tds {
--do
--    Expression^tds := SuiteAffectable^tds;
--    SuiteAffectable1^tds := SuiteAffectable^tds;
--end
--}

--#inh {
--do
--    SuiteAffectable1^support := SuiteAffectable^factory.createArrayAssignment(SuiteAffectable^support,Expression^ast);  
--end
--}

--#ast {
--do
--    SuiteAffectable^ast := SuiteAffectable1^ast;   
--end
--}


Instruction -> si parenthese_ouvrante #tds Expression parenthese_fermante Bloc SuiteConditionnelle #instr ;
#tds {
do
    Expression^tds := Instruction^tds;
    SuiteConditionnelle^tds := Instruction^tds;
    
    Bloc^tds := new SymbolTable(Instruction^tds);
end
}

#instr {
local
    sc_bloc : Block;
do
    sc_bloc := SuiteConditionnelle^suite_cond_bloc;
    
    if sc_bloc = null then
        Instruction^instr := Instruction^factory.createConditional(Expression^ast, Bloc^ast);
    else
        Instruction^instr := Instruction^factory.createConditional(Expression^ast, Bloc^ast, sc_bloc);
    end
end
}


SuiteConditionnelle -> #suite_cond_bloc ;
#suite_cond_bloc {
do
    SuiteConditionnelle^suite_cond_bloc := null;
end
}

SuiteConditionnelle -> sinon #tds Bloc #suite_cond_bloc ;
#tds {
do
    Bloc^tds := new SymbolTable(SuiteConditionnelle^tds);
end
}

#suite_cond_bloc {
do
    SuiteConditionnelle^suite_cond_bloc := Bloc^ast;
end
}

Instruction -> tant_que parenthese_ouvrante #tds Expression parenthese_fermante Bloc #instr ;
#tds {
do
    Expression^tds := Instruction^tds;
    Bloc^tds := new SymbolTable(Instruction^tds);
end
}

#instr {
do
    Instruction^instr := Instruction^factory.createRepetition(Expression^ast, Bloc^ast);
end
}


Instruction -> afficher Expression point_virgule #instr ;
#instr {
do
    Instruction^instr := Instruction^factory.createPrinter(Expression^ast);
end
}

Instruction -> retour #tds Expression point_virgule #instr;
#tds {
do
    Expression^tds := Instruction^tds;
end
}

#instr {
do
    Instruction^instr := Instruction^factory.createReturn(Expression^ast, null);
end
}



Expression -> #tds Condition #inh SuiteCondition #ast ;
#tds {
do
    Condition^tds := Expression^tds;
    SuiteCondition^tds := Expression^tds;
end
}

#inh {
do
    SuiteCondition^gauche := Condition^ast;
end 
}

#ast {
do
    Expression^ast := SuiteCondition^ast;
end 
}


SuiteCondition -> #tds Comparatif Condition #ast ;
#tds {
do
    Condition^tds := SuiteCondition^tds;
end
}

#ast {
do
    SuiteCondition^ast :=
    SuiteCondition^factory.createBinaryExpression(
        SuiteCondition^gauche,
        Comparatif^bin_op,
        Condition^ast);
end 
}

SuiteCondition -> #ast ;
#ast {
do
    SuiteCondition^ast := SuiteCondition^gauche;
end 
}


Comparatif -> egalite #texte ;
#texte {
do
    Comparatif^bin_op := BinaryOperator.Equals;
end
}

Comparatif -> different #texte ;
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Different;   
end  
}

Comparatif -> inferieur #texte ;
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Lesser;   
end  
}

Comparatif -> inferieur_egal #texte ;
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.LesserOrEqual;   
end  
}

Comparatif -> superieur #texte ;
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.Greater;    
end  
}

Comparatif -> superieur_egal #texte ;
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.GreaterOrEqual;    
end  
}

   
Condition -> #tds Terme #ast_inh SuiteTerme #ast_syn ;
#tds {
do
    Terme^tds := Condition^tds;
    SuiteTerme^tds := Condition^tds;
end
}

#ast_inh {
do 
    SuiteTerme^gauche := Terme^ast; 
end 
}

#ast_syn {
do
    Condition^ast := SuiteTerme^ast; 
end
}


SuiteTerme -> Additif #tds Terme #ast_inh SuiteTerme #ast_syn ;
#tds {
do
    SuiteTerme1^tds := SuiteTerme^tds;
    Terme^tds := SuiteTerme^tds;
end
}

#ast_inh {
do
    SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
	  SuiteTerme^gauche,  
	  Additif^bin_op,  
	  Terme^ast);  
end 
}

#ast_syn {
do 
    SuiteTerme^ast := SuiteTerme1^ast; 
end 
}

SuiteTerme -> #ast ;
#ast {
do
    SuiteTerme^ast := SuiteTerme^gauche;
end
}

Additif -> addition #ast;  
#ast { 
do  
    Additif^bin_op := BinaryOperator.Add;  
end  
}

Additif -> soustraction #ast;  
#ast {  
do  
    Additif^bin_op := BinaryOperator.Substract;   
end  
}
   
Additif -> ou #ast;  
#ast {  
do
    Additif^bin_op := BinaryOperator.Or;   
end  
}
  
Terme -> #tds Facteur #ast_inh SuiteFacteur #ast_syn ;
#tds {
do
    Facteur^tds := Terme^tds;
    SuiteFacteur^tds := Terme^tds;
end
}
#ast_inh {
do 
    SuiteFacteur^gauche := Facteur^ast; 
end 
}

#ast_syn {
do
    Terme^ast := SuiteFacteur^ast; 
end
}

SuiteFacteur -> Multiplicatif #tds Facteur #ast_inh SuiteFacteur #ast_syn ;
#tds {
do
    Facteur^tds := SuiteFacteur^tds;
    SuiteFacteur1^tds := SuiteFacteur^tds;
end
}

#ast_inh {
do 
    SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
	  SuiteFacteur^gauche,  
	  Multiplicatif^bin_op,  
	  Facteur^ast);  
end 
}

#ast_syn {
do 
    SuiteFacteur^ast := SuiteFacteur1^ast; 
end 
}
 
SuiteFacteur -> #ast;  
#ast {
do
    SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

Multiplicatif -> multiplication #ast; 
#ast {
do 
    Multiplicatif^bin_op := BinaryOperator.Multiply; 
end 
}

Multiplicatif -> division #ast; 
#ast { 
do 
    Multiplicatif^bin_op := BinaryOperator.Divide;  
end 
}
 
Multiplicatif -> modulo #ast; 
#ast {  
do 
    Multiplicatif^bin_op := BinaryOperator.Modulo;   
end 
}
  
Multiplicatif -> et #ast; 
#ast {  
do 
    Multiplicatif^bin_op := BinaryOperator.And;   
end 
}

  
--Facteur -> accolade_ouvrante #tds Expressions accolade_fermante #ast ;
--#tds {
--do
--    Expressions^tds := Facteur^tds;
--end
--}

--#ast {
--do
--    Facteur^ast := Facteur^factory.createSequence( Expressions^expressions );
--end
--}


Expressions -> #tds Expression SuiteExpressions #ast ;
#tds {
do
    Expression^factory := new BlockFactoryImpl();
    Expression^tds := Expressions^tds;
    SuiteExpressions^tds := Expressions^tds;
end
}

#ast {
do 
    SuiteExpressions^expressions.addFirst(Expression^ast); 
    Expressions^expressions := SuiteExpressions^expressions; 
end 
}

SuiteExpressions -> virgule #tds Expression SuiteExpressions #ast ;
#tds {
do
    Expression^factory := new BlockFactoryImpl();
    Expression^tds := SuiteExpressions^tds;
    SuiteExpressions1^tds := SuiteExpressions^tds;
end
}

#ast {
do 
    SuiteExpressions1^expressions.addFirst(Expression^ast); 
    SuiteExpressions^expressions := SuiteExpressions1^expressions; 
end 
}

SuiteExpressions -> #ast ;
#ast {
do
    SuiteExpressions^expressions := new LinkedList<Expression>();
end
}


Facteur -> soustraction #tds Facteur #ast ;  
#tds {
do
    Facteur1^tds := Facteur^tds;
end
}

#ast { 
do  
    Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);  
end  
}  

Facteur -> negation #tds Facteur #ast ;  
#tds {
do
    Facteur1^tds := Facteur^tds;
end
}

#ast {
do
    Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);  
end
}

Facteur -> nouveau #tds Type #inh SuiteNouveau #ast ; 
#tds {
do
    Type^tds := Facteur^tds;
    SuiteNouveau^tds := Facteur^tds;
end
}

#inh {
do 
    SuiteNouveau^type := Type^ast; 
end
}

#ast {
do 
    Facteur^ast := SuiteNouveau^ast; 
end 
}


SuiteNouveau -> crochet_ouvrant #tds Expression crochet_fermant #ast ;
#tds {
do
    Expression^tds := SuiteNouveau^tds;
end
}

#ast {
do  
    --SuiteNouveau^ast := SuiteNouveau^factory.createArrayAllocation(SuiteNouveau^type,Expression^ast);
    SuiteNouveau^ast := null;
end  
}

SuiteNouveau -> #tds Arguments #ast ;
#tds {
do
    Arguments^tds := SuiteNouveau^tds;
end
}

#ast {
local
    alloc : Expression;
do 
    match SuiteNouveau^type
        with ClasseTypeImpl then
            alloc := SuiteNouveau^factory.createClasseInstanceAllocation(
                                SuiteNouveau^type.getClasse(),
                                Arguments^args);
            
            match alloc with ClasseInstanceAllocationImpl then
                
                if alloc.estCorrect() then
                    SuiteNouveau^ast := alloc;
                else
                    SuiteNouveau^ast := null;
                    error(MiniJava_allocation_incorrecte, SuiteNouveau^type.toString());
                end
            else
                SuiteNouveau^ast := null;
                error(MiniJava_allocation_incorrecte, SuiteNouveau^type.toString());
            end
        
        with UndeclaredTypeImpl then
            SuiteNouveau^ast := SuiteNouveau^factory.createUndeclaredAllocation(
                                SuiteNouveau^type.getNom(),
                                Arguments^args);
        else
            error(MiniJava_badtype_classe, SuiteNouveau^type.toString());
    end
end 
}

Arguments -> parenthese_ouvrante parenthese_fermante #args ;
#args {
do
    Arguments^args := new LinkedList<Expression>();
end
}

Arguments -> parenthese_ouvrante #tds Expressions parenthese_fermante #args ;
#tds {
do
    Expressions^tds := Arguments^tds;
end
}

#args {
do
    Arguments^args := Expressions^expressions;
end
}


Facteur -> Valeur #ast;
#ast {
do
    Facteur^ast := Valeur^ast;
end
}

 
Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt); 
end
}

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);  
end
}

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);  
end
}

Valeur -> chaine #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createStringValue(chaine^txt);  
end
}

Valeur -> caractere #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createCharValue(caractere^txt);  
end
}


Facteur -> identificateur #tds #inh AppelOuAcces #ast;
#tds {
do
    AppelOuAcces^tds := Facteur^tds;
    --AppelOuAcces^premier_identificateur := identificateur^txt
end
}

#inh {
local
   f : Optional<Declaration>;
   d : Declaration;
do
   if (Facteur^tds.knows(identificateur^txt)) then
      f := Facteur^tds.get(identificateur^txt);
      d := f.get();
      match d
        with ConstantDeclaration then AppelOuAcces^support := d.getValue();
        
        with UndeclaredInstanceDeclaration then AppelOuAcces^support := Facteur^factory.createUndeclaredInstanceUse(d);
      
        with ClasseInstanceDeclaration then AppelOuAcces^support := Facteur^factory.createInstanceUse(d);
        
        with VariableDeclaration then AppelOuAcces^support := Facteur^factory.createVariableUse(d);
      
      end
   else
        --On le définit comme une tentative (dans un premier temps) d'accès à un membre de classe.
        if (identificateur^txt.equals("this")) then
            AppelOuAcces^support := Facteur^factory.createMembreClasseAccess_identifier(Identifier.THIS, "");
        else
            if (identificateur^txt.equals("super")) then
                AppelOuAcces^support := Facteur^factory.createMembreClasseAccess_identifier(Identifier.SUPER, "");
            else
                AppelOuAcces^support := Facteur^factory.createMembreClasseAccess_identifier(Identifier.UNKNOWN, identificateur^txt);
            end
        end
   end
end
}

#ast {
do
    Facteur^ast := AppelOuAcces^ast;
end
}


AppelOuAcces -> #tds Acces #ast ;
#tds {
do
    Acces^tds := AppelOuAcces^tds;
    Acces^support := AppelOuAcces^support;
end
}

#ast {
do
    AppelOuAcces^ast := Acces^ast;
end
}

AppelOuAcces -> #tds Appel #ast ;
#tds {
do
    Appel^tds := AppelOuAcces^tds;
    Appel^support := AppelOuAcces^support;
end
}

#ast {
do
    AppelOuAcces^ast := Appel^ast;
end
}


Acces -> #ast ;
#ast {
do  
    Acces^ast := Acces^support;  
end  
}

Acces -> crochet_ouvrant #tds Expression crochet_fermant #inh Acces #ast;
#tds {
do
    Acces1^tds := Acces^tds;
    Expression^tds := Acces^tds;
end
}

#inh {
do
    Acces1^support := Acces^factory.createArrayAccess(Acces^support,Expression^ast);
end
}

#ast { 
do  
    Acces^ast := Acces1^ast;  
end
}


Acces -> point identificateur #tds #inh AppelOuAcces #ast ;
#tds {
do
    AppelOuAcces^tds := Acces^tds;
end
}

#inh {
local
    supp : Expression;
    
    dec : ClasseInstanceDeclaration;
do
    supp := Acces^support;
    match supp
        with InstanceUseImpl then
            AppelOuAcces^support := Acces^factory.createInstanceAccess_use(supp, identificateur^txt);
        
        with InstanceAccessImpl then
            AppelOuAcces^support := Acces^factory.createInstanceAccess_access(supp, identificateur^txt);
            
		with UndeclaredInstanceUseImpl then
            AppelOuAcces^support := Acces^factory.createUndeclaredAccess_use(supp, identificateur^txt);
        
        with UndeclaredAccessImpl then
            AppelOuAcces^support := Acces^factory.createUndeclaredAccess_access(supp, identificateur^txt);
        
        with MembreClasseAccessImpl then
            if (!supp.isNameDeclared()) then
                supp.setNomAcces(identificateur^txt);
                AppelOuAcces^support := supp;
            else
                AppelOuAcces^support := Acces^factory.createMembreClasseAccess_access(supp, identificateur^txt);
            end
       
        else error(MiniJava_Acces_NonImplemente);
    end
end
}

#ast {
do
    Acces^ast := AppelOuAcces^ast;
end
}

Appel -> #tds Arguments #inh Acces #ast ;
#tds {
do
    Arguments^tds := Appel^tds;
    Acces^tds := Appel^tds;
end
}

#inh {
local
    d : Expression;
    dec : ClasseInstanceDeclaration;
do
    d := Appel^support;
    
    match d
        with InstanceAccessImpl then
            dec := d.getDeclaration();
            
            d.setArgumentsAcces(Arguments^args);
            
            Acces^support := d;
        
        with UndeclaredAccessImpl then
            d.setArgumentsAcces(Arguments^args);
            Acces^support := d;
        
        with MembreClasseAccessImpl then
            d.setArgumentsAcces(Arguments^args);
            Acces^support := d;
        
        else error(MiniJava_Appel_NonImplemente);
    end
end
}

#ast {
do
    Appel^ast := Acces^ast;
end
}


Facteur -> identificateur_type #tds  point identificateur #inh AppelOuAcces #ast;
#tds {
do
    AppelOuAcces^tds := Facteur^tds;
end
}

#inh {
local
   f : Optional<Declaration>;
   d : Declaration;
   interf : Interface;
do
   if (Facteur^tds.knows(identificateur_type^txt)) then
      f := Facteur^tds.get(identificateur_type^txt);
      d := f.get();
      match d
      with InterfaceDeclaration then 
			interf := d.getInterface();
			if (interf.isPresentConstante(identificateur^txt)) then
				AppelOuAcces^support := interf.getValueConstante(identificateur^txt);
			else 
				error(MiniJava_undefined_ident, identificateur^txt);
			end
	  else
		error(MiniJava_badtype_classe, identificateur^txt);
      end
   else
      error(MiniJava_undefined_ident, identificateur_type^txt);
   end
end
}

#ast {
do
	Facteur^ast := AppelOuAcces^ast;
end
}

--Facteur -> parenthese_ouvrante Expression parenthese_fermante ;

end
